<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo Next主题配置更改及优化</title>
    <url>/2020/08/30/Hexo%20Next%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%9B%B4%E6%94%B9%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><img data-src="https://user-images.githubusercontent.com/16272760/63487983-da41b080-c4df-11e9-951c-64883a8a5e9b.png"></p>
<p><a href="https://theme-next.iissnan.com/"><strong>Next</strong></a>主题是使用人数较多的一款主题，在于其精简易用，提供了不同的主题风格和样式配置。由于<a href="https://theme-next.iissnan.com/theme-settings.html">Next官方文档</a>并未收录所有配置修改说明，所以本文重点总结一些常用的配置修改方法以及增加一些扩展效果。</p>
<p>欢迎留言补充说明。（由于版本更迭，有的方法可能不再适用，当前版本<a href="https://github.com/theme-next/hexo-theme-next"><code>V7.8.0</code></a>）</p>
<a id="more"></a>

<h2 id="布局修改"><a href="#布局修改" class="headerlink" title="布局修改"></a>布局修改</h2><p><code>Next</code>提供了四种主题布局样式，在<strong>主题配置文件</strong>中搜索关键词：<code>Schemes</code>，可以发现有以下布局样式可供选择：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>可以尝试修改后调整为自己喜欢的布局样式。（对应文章开头图片的四种样式）</p>
<h2 id="主页菜单修改"><a href="#主页菜单修改" class="headerlink" title="主页菜单修改"></a>主页菜单修改</h2><h3 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h3><p><code>Next</code>默认可能只开启了<strong>首页</strong>和<strong>归档</strong>两个菜单，如果需要新增或自定义类似下面的菜单：</p>
<p><img data-src="/images/image-20200830163445222.png"></p>
<p>在<strong>主题配置文件</strong>中搜索关键词<code>menu</code>：（有翻译配置的会自动转换翻译）</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Usage: `Key: /link/ || icon`</span><br><span class="line"># External url should start with http:// or https://</span><br><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  # schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  # sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  # commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<p>一个菜单我们需要配置三个参数，对应格式为：<code>菜单名称: 连接 || 图标</code>。</p>
<h3 id="跳转效果"><a href="#跳转效果" class="headerlink" title="跳转效果"></a>跳转效果</h3><p>当我们配置了菜单之后，可能点击是<code>404</code>界面，这是因为我们还没有为菜单创建对应链接下的访问目录和内容，以<code>tags</code>菜单为例，具体操作如下：</p>
<p>回到<code>Hexo</code>项目根目录，执行<code>new page</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>这样，会在<code>Hexo</code>的<code>source</code>目录下生成一个<code>tags</code>目录，并初始化一个<code>index.md</code>文件，而当我们访问<code>/tags</code>时便是访问<code>tags</code>目录下的这个<code>index.md</code>生成的<code>html</code>文件。</p>
<p>为了能看到内容，我们需要修改这个文件，你可以自定义你需要展示的内容，在这里，<code>tags</code>比较特殊，我们希望展示站点的所有标签信息，我们不可能手动添加，所以<code>Hexo</code>为我们内置了<code>标签页</code>的生成方法，我们只需要简单修改这个文件的<strong>头信息</strong>就能自动生成：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>重点是这个<code>type</code>字段，我们指定为<code>tags</code>之后，<code>Hexo</code>就会自动为我们创建标签页，类似的还有分类页<code>categories</code>，把<code>type</code>设置为<code>categories</code>即可。</p>
<h2 id="展示文章字数统计和阅读时长信息"><a href="#展示文章字数统计和阅读时长信息" class="headerlink" title="展示文章字数统计和阅读时长信息"></a>展示文章字数统计和阅读时长信息</h2><p>这是<code>Hexo</code>提供的一个插件，<code>Next</code>也支持了这个插件，所以我们只需要安装并修改<strong>主题配置文件</strong>即可：</p>
<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>搜索关键字：<code>symbols_count_time</code>，没有的话需要新增：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true #显示字数</span><br><span class="line">  time: true #显示阅读时长</span><br><span class="line">  item_text_post: false #是否显示图标</span><br><span class="line">  item_text_total: false</span><br><span class="line">  separated_meta: false #是否换行显示</span><br><span class="line">  awl: 4 #平均字长(以字接为单位)</span><br><span class="line">  wpm: 275 #每分钟字数。默认值：275</span><br><span class="line">  suffix: &quot;mins.&quot; #阅读显示单位</span><br></pre></td></tr></table></figure>

<h2 id="代码块样式修改"><a href="#代码块样式修改" class="headerlink" title="代码块样式修改"></a>代码块样式修改</h2><p><code>Next</code>提供了多种样式可供选择，搜索关键字：<code>codeblock</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">codeblock:</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span><br><span class="line">  # See: https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">  highlight_theme: night eighties #代码块主题样式</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true #是否开启复制按钮</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac #复制按钮主题样式</span><br></pre></td></tr></table></figure>

<h2 id="增加打赏功能"><a href="#增加打赏功能" class="headerlink" title="增加打赏功能"></a>增加打赏功能</h2><p>在<strong>主题配置文件</strong>中搜索关键词：<code>reward_settings</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">reward_settings:</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true #是否开启动画效果</span><br><span class="line">  comment: #在打赏界面显示你要说的话</span><br></pre></td></tr></table></figure>

<p>然后再搜索关键词<code>reward</code>，展示你需要展示的支付图片：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png</span><br><span class="line">  alipay: /images/alipay.jpg</span><br><span class="line">  #paypal: /images/paypal.png</span><br><span class="line">  #bitcoin: /images/bitcoin.png</span><br></pre></td></tr></table></figure>

<p>根据上面的配置，把图片复制到<code>Hexo</code>根目录的<code>source/images</code>目录下。</p>
<h2 id="增加版权信息"><a href="#增加版权信息" class="headerlink" title="增加版权信息"></a>增加版权信息</h2><p>在<strong>主题配置文件</strong>中搜索关键词：<code>creative_commons</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span><br><span class="line">creative_commons:</span><br><span class="line">  license: by-nc-sa #使用的协议</span><br><span class="line">  sidebar: false #首页侧边栏显示</span><br><span class="line">  post: true #文章底部显示</span><br><span class="line">  language: #语言</span><br></pre></td></tr></table></figure>

<p>然后在文章底部就会自动生成这样的说明信息：</p>
<p><img data-src="/images/image-20200830174347283.png"></p>
<h2 id="展示站点访问人数统计"><a href="#展示站点访问人数统计" class="headerlink" title="展示站点访问人数统计"></a>展示站点访问人数统计</h2><p><code>Next</code>内置了<code>卜蒜子</code>统计插件，所以只需要修改配置就好了，在<strong>主题配置文件</strong>中搜索关键词：<code>busuanzi_count</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: fa fa-eye</span><br></pre></td></tr></table></figure>

<h2 id="显示页面加载进度条"><a href="#显示页面加载进度条" class="headerlink" title="显示页面加载进度条"></a>显示页面加载进度条</h2><p><code>Next</code>使用了<strong>pace模块</strong>功能，</p>
<p>需要先安装这个模块到<code>Next</code>主题文件夹下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-pace source/lib/pace</span><br></pre></td></tr></table></figure>

<p>然后修改配置文件，搜索关键词<code>pace</code>或自己添加：(多种样式可供选择)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  # Themes list:</span><br><span class="line">  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">  theme: minimal</span><br></pre></td></tr></table></figure>

<h2 id="动态背景"><a href="#动态背景" class="headerlink" title="动态背景"></a>动态背景</h2><p><code>Next</code>内置了三种动态背景，可能会造成界面打开缓慢和卡顿，根据自己需求觉得是否安装：</p>
<ul>
<li><a href="https://github.com/theme-next/theme-next-canvas-nest">Canvas-nest</a></li>
<li><a href="https://github.com/theme-next/theme-next-three">JavaScript 3D library</a></li>
<li><a href="https://github.com/theme-next/theme-next-canvas-ribbon">Canvas-ribbon</a></li>
</ul>
<p>以安装<code>canvas-nest</code>为例：</p>
<p>下载安装模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nest</span><br></pre></td></tr></table></figure>

<p>修改或添加主题配置文件文件，搜索关键词：<code>canvas_nest</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # Display on mobile or not</span><br><span class="line">  color: &quot;0,0,255&quot; # RGB values, use `,` to separate</span><br><span class="line">  opacity: 0.5 # The opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 99 # The number of lines</span><br></pre></td></tr></table></figure>

<h2 id="静态背景"><a href="#静态背景" class="headerlink" title="静态背景"></a>静态背景</h2><p>如果觉得动态背景卡顿或太花哨，你也可以只设置一张静态背景。</p>
<p>背景是简单的<code>css</code>设置的，所以我们需要插入一段<code>css</code>代码来覆盖默认设置。</p>
<p>在主题的<code>css</code>目录即：<code>hexo\themes\next\source\css</code>下有一个<code>main.styl</code>文件，这就是站点最终要的打包<code>css</code>文件，我们不建议直接修改这个文件，所以我们在css文件目录下新建一个文件<code>custom.styl</code>（可以换别的名字），表示这是我们自定义的<code>css</code>代码，增加以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义的部分</span></span><br><span class="line">body &#123;</span><br><span class="line">  background-image: url(<span class="regexp">/images/</span>bg.png)</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-attachment:fixed;</span><br><span class="line">  background-size: cover;</span><br><span class="line">  background-position:<span class="number">50</span>% <span class="number">50</span>%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//博客内容透明化</span></span><br><span class="line"><span class="comment">//文章内容的透明度设置</span></span><br><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: <span class="number">0.95</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line">.sidebar &#123;</span><br><span class="line">  opacity: <span class="number">0.9</span>;</span><br><span class="line">  background-color:transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果了解<code>css</code>可自行修改样式。正如样式中的<code>background-image</code>，我们设置了<code>url</code>为<code>/images/bg.png</code>的图片作为背景，这里你可以更改为动态链接，否则，你需要再准备一张背景图片放到<code>hexo\themes\next\source\images</code>目录下。</p>
<p>现在我们，需要把新增的这个文件嵌入<code>main.styl</code>文件中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// ------------------插入自定义样式文件</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;custom&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="自定义404界面"><a href="#自定义404界面" class="headerlink" title="自定义404界面"></a>自定义404界面</h2><p>有时候遇到打不开的链接或者别的特殊情况，常常弹出<code>404</code>界面，我们可以自定义这个界面。有两个方法可以实现：</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>首先需要创建<code>404</code>目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page 404</span><br></pre></td></tr></table></figure>

<p>然后，修改目录下的<code>index.md</code>文件即可。</p>
<h3 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h3><p>直接在<code>next</code>主题目录<code>hexo\themes\next\source</code>下添加<code>404.html</code>文件即可，比如下面的腾讯404工业界面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=utf-8;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;all&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/plain&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.qq.com/404/search_children.js&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">homePageUrl</span>=<span class="string">&quot;/&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">homePageName</span>=<span class="string">&quot;回到我的主页&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/data.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://qzone.qq.com/gy/404/page.js&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h2><p><code>Next</code>默认不显示头像，在<strong>主题配置文件</strong>中搜索关键词：<code>avatar</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.gif</span><br><span class="line">  rounded: true #圆形头像</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false #动画效果</span><br></pre></td></tr></table></figure>

<p>根据<code>url</code>的路径添加对应的图片即可。</p>
<h2 id="添加站点搜索按钮"><a href="#添加站点搜索按钮" class="headerlink" title="添加站点搜索按钮"></a>添加站点搜索按钮</h2><p><code>Next</code>内置的效果，在<strong>主题配置文件</strong>中搜索关键词：<code>local_search</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # 设置为 auto 时输入时自动触发搜索；设置为 manual 时使用enter回车或者点击搜索按钮才会执行搜索</span><br><span class="line">  trigger: auto</span><br><span class="line">  # 显示每篇文章的前n个结果，通过设置为-1显示所有结果</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  # 将html字符串转义为可读的字符串</span><br><span class="line">  unescape: false</span><br><span class="line">  # 页面加载时预加载搜索数据。</span><br><span class="line">  preload: false</span><br></pre></td></tr></table></figure>

<h2 id="增加图片放大预览功能"><a href="#增加图片放大预览功能" class="headerlink" title="增加图片放大预览功能"></a>增加图片放大预览功能</h2><p>利用<code>Fancybox</code>来放大查看和播放图片。</p>
<p><code>Fancybox</code>有不同的版本，如果需要安装新版本，需要先清除已经安装的旧版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf themes/next/source/lib/fancybox</span><br></pre></td></tr></table></figure>

<p>然后进入<code>next</code>主题目录安装新版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox</span><br></pre></td></tr></table></figure>

<p>最后修改<strong>主题配置文件</strong>即可：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># For more information: https://fancyapps.com/fancybox</span><br><span class="line">fancybox: ture</span><br></pre></td></tr></table></figure>

<h2 id="回到顶部样式优化"><a href="#回到顶部样式优化" class="headerlink" title="回到顶部样式优化"></a>回到顶部样式优化</h2><p>首先回到顶部有配置是可以修改的，在<strong>主题配置文件</strong>中搜索关键词：<code>back2top</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # 在sidebar显示</span><br><span class="line">  sidebar: false</span><br><span class="line">  # 显示百分比</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>

<p>默认的回到顶部是个<strong>小箭头</strong>，如果你觉得单调，可以使用<code>css</code>换成你想要的样式，既然使用到了<code>css</code>，就如同文章目录<strong>静态背景</strong>这一节的操作一样，我们把新增的<code>css</code>代码写到<code>custom.styl</code>中就好了。</p>
<p>比如，我们新增这样一些样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//自定义回到顶部样式</span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">5px</span>;</span><br><span class="line">  width: 70px;  //图片素材宽度</span><br><span class="line">  height: 900px;  //图片素材高度</span><br><span class="line">  <span class="selector-tag">top</span>: <span class="selector-tag">-900px</span>;</span><br><span class="line">  <span class="selector-tag">bottom</span>: <span class="selector-tag">unset</span>;</span><br><span class="line">  <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.5s</span> <span class="selector-tag">ease-in-out</span>;</span><br><span class="line">  background: url(/images/backtop.png);</span><br><span class="line"></span><br><span class="line">  //隐藏箭头图标</span><br><span class="line">  &gt; <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">93px</span>);</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">9px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#853f39</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: unset;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? <span class="built_in">calc</span>( <span class="number">100vh</span> - <span class="number">900px</span> - <span class="number">200px</span> ) : <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样式中，我们使用了一张背景图，我们把它放到<code>hexo\themes\next\source\images</code>目录下即可看到下面的样式：</p>
<p><img data-src="/images/5f4b86b846a0b_5f4b86b8c30cf.gif" alt="5f4b86b846a0b_5f4b86b8c30cf"></p>
<p>点击这里可以下载这张图片：</p>
<a class="btn" href="/images/scroll.png" download="">
  <i class="fa fa-download fa-fw"></i> backtop </a>

<h2 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h2><h3 id="Valine评论系统"><a href="#Valine评论系统" class="headerlink" title="Valine评论系统"></a>Valine评论系统</h3><p><code>Next</code>内置了多种评论系统，你可以选择一款或者同时使用多款，这里以<code>Valine </code>的安装为例：</p>
<p> Valine 评论系统，不需要登录，没有后端，关键还支持<code>markdown</code>语法，它的一些特点：</p>
<ul>
<li>基于 Leancloud 的系统</li>
<li>支持 MarkDown 语法</li>
<li>无后端实现，快速高效</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p>注册<code>LeanCloud </code></p>
<p>因为 <code>Valine</code> 是基于 <code>LeanCloud</code> 系统的，所以先在 <code>LeanCloud </code>中注册账号。</p>
<p>注册登陆后，访问控制台，创建应用，选择开发版，创建好之后就生成了 <code>App ID</code> 和 <code>App Key</code>，这两个信息需要填写到配置文件中。</p>
</li>
<li><p>修改主题配置文件</p>
<p>搜索关键字<code> Valine</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># For more information: https://valine.js.org, https://github.com/xCss/Valine, https://valine.js.org/hexo.html</span><br><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: #这里填写你的App ID</span><br><span class="line">  appkey: #这里填写你的App key</span><br><span class="line">  notify: false # Mail notifier</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: 说点什么? # Comment box placeholder</span><br><span class="line">  avatar: monsterid # https://valine.js.org/avatar.html</span><br><span class="line">  guest_info: nick,mail,link # Custom comment header</span><br><span class="line">  pageSize: 10 # Pagination size</span><br><span class="line">  language: # Language, available values: en, zh-cn</span><br><span class="line">  visitor: true # Article reading statistic</span><br><span class="line">  comment_count: true # If false, comment count will only be displayed in post page, not in home page</span><br><span class="line">  recordIP: false # Whether to record the commenter IP</span><br><span class="line">  serverURLs: # When the custom domain name is enabled, fill it in here (it will be detected automatically by default, no need to fill in)</span><br><span class="line">  #post_meta_order: 0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>本文使用的即<code>Valine</code>评论系统，欢迎滑到底部查看效果，或留下你的足迹。</p>
<h2 id="添加点击和Typing特效"><a href="#添加点击和Typing特效" class="headerlink" title="添加点击和Typing特效"></a>添加点击和Typing特效</h2><p><a href="http://yearito.cn/posts/hexo-theme-beautify.html">TODO</a></p>
<h2 id="添加看板娘"><a href="#添加看板娘" class="headerlink" title="添加看板娘"></a>添加看板娘</h2><p>TODO</p>
<h2 id="插入node提示块"><a href="#插入node提示块" class="headerlink" title="插入node提示块"></a>插入node提示块</h2><p><a href="https://jinnsjj.github.io/uncategorized/hexo-next-note/">TODO</a></p>
]]></content>
      <categories>
        <category>guide</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用指令总结</title>
    <url>/2020/08/23/git%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p><img data-src="/images/git.png" alt="git"></p>
<p>在这里记录一些常用的<code>git</code>指令，以及使用时碰到的一些问题及相应的解决办法。</p>
<a id="more"></a>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git init [local repository]</span><br></pre></td></tr></table></figure>

<h2 id="克隆到本地"><a href="#克隆到本地" class="headerlink" title="克隆到本地"></a>克隆到本地</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure>

<h2 id="添加变化至暂存区-index"><a href="#添加变化至暂存区-index" class="headerlink" title="添加变化至暂存区(index)"></a>添加变化至暂存区(index)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add *</span><br><span class="line">git commit -m &quot;&lt;commit message&gt;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送到指定的远程分支</span></span><br><span class="line">git push oringin &lt;master&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 绑定远程分支并推送</span></span><br><span class="line">git romete add origin &lt;master&gt;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<h2 id="分支-branch-相关"><a href="#分支-branch-相关" class="headerlink" title="分支(branch)相关"></a>分支(branch)相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch # 查看本地分支</span><br><span class="line">git branch -r # 查看远程分支</span><br><span class="line">git branch -a # 查看所有分支</span><br><span class="line"></span><br><span class="line">git checkout -b &lt;dev&gt; # 创建本地分支</span><br><span class="line">git checkout &lt;dev&gt; # 切换到本地分支（没有会根据远程分支创建本地分支）</span><br><span class="line"></span><br><span class="line">git branch -d &lt;dev&gt; # 删除本地分支</span><br><span class="line">git push origin -d &lt;remote_dev&gt; # 删除远程分支</span><br><span class="line"></span><br><span class="line">git push origin &lt;dev&gt; # 推送到远程分支，没有会自动创建</span><br><span class="line"></span><br><span class="line">git checkout [branch name] # 切换分支</span><br></pre></td></tr></table></figure>

<h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull</span><br><span class="line">git fetch [origin]</span><br></pre></td></tr></table></figure>

<h2 id="缓存-stash-相关"><a href="#缓存-stash-相关" class="headerlink" title="缓存(stash)相关"></a>缓存(stash)相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash list</span><br><span class="line">git stash save &#x27;&lt;stash name&gt;&#x27;</span><br><span class="line">git stash show</span><br><span class="line">git stash show -p</span><br><span class="line">git stash apply [@&#123;num&#125;]</span><br><span class="line">git stash pop [@&#123;num&#125;]</span><br><span class="line">git stash drop</span><br><span class="line">git stash clear</span><br></pre></td></tr></table></figure>

<h2 id="状态-status"><a href="#状态-status" class="headerlink" title="状态(status)"></a>状态(status)</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>guide</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript性能优化</title>
    <url>/2020/10/15/JavaScript%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>性能优化一直是代码开发阶段不可避免也十分重要的环节，本文将从<strong>内存管理</strong>这一方面来阐述<code>JavaScript</code>的优化方法，具体包括：内存管理概述、垃圾回收与常见的GC算法、V8引擎的GC算法、js语言内存优化实例。</p>
<p><img data-src="/images/performance.png" alt="performance"></p>
<a id="more"></a>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><blockquote>
<p>类似C这样偏底层的语言，一般都有内存管理接口，比如申请内存<code>malloc()</code>和释放内存<code>free()</code>。而像<code>javaScript</code>这样的高级语言则是在创建变量时<strong>自动分配</strong>内存，在不使用时<strong>自动回收</strong>内存资源。其中，自动回收资源也称为<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收</a>(Garbage Collection)，简称<code>GC</code>。</p>
</blockquote>
<p>这种自动化的内存管理常常让corder难以感知和控制内存的变化，提高了编程体验的同时会让不规范或者未加控制的代码设计问题造成<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a>。内存泄漏会导致程序无法继续执行乃至崩溃，所以学习如果观察内存变化，以及合理的代码编写规范是值得关注的。</p>
<h3 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h3><p>内存是一片由可读写单元组成的可操作空间，内存一般的生命周期为：</p>
<ul>
<li>申请内存</li>
<li>操作内存（读写）</li>
<li>释放内存（归还）</li>
</ul>
<p>在<code>js</code>中，内存的申请和释放是自动的，我们只是在使用内存。当我们申明一个变量后，<code>js</code>就会自动申请内存空间，而变量的使用就是在操作内存，至于释放，也就是<code>js引擎</code>的自动垃圾回收。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>内存泄漏的本质就是内存无法被释放，未使用的内存资源也就是垃圾无法被正常回收，了解垃圾的回收机制可以帮助我们在编写代码时能让垃圾回收正常运行，避免内存溢出。</p>
<p><code>js</code>中的垃圾（无用内存空间）一般有以下特征：</p>
<ul>
<li>对象不再被引用时为垃圾</li>
<li>对象无法从根上访问时为垃圾（根就是全局作用域）</li>
</ul>
<p>我们观察这样一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    left: &#123;</span><br><span class="line">        name: <span class="string">&#x27;left&#x27;</span>,</span><br><span class="line">        next: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    right: &#123;</span><br><span class="line">        name: <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">        next: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.left.next = obj.right</span><br><span class="line">obj.right.next = obj.left</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>代码片段中变量<code>obj</code>指向了一个对象，对象内部的left对象和right对象存在<strong>相互引用</strong>，当执行<code>obj = null</code>或者其他赋值语句后，该对象的唯一引用被切断，也就是说原来<code>obj</code>所指向的对象无法再访问到，属于垃圾的定义，需要被回收，而该对象的left和right对象虽然存在引用，但无法从全局作用域被访问到，同样也属于垃圾。</p>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p>从垃圾的定义出发，不再使用的对象或者说无法访问的对象就归属为垃圾，而<code>GC</code>算法的主要的目标就是寻找到这些无用的存储。常见的GC算法如下文所示。</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法的原理很简单，当某个对象的被引用数目为0时，说明该对象无法再被访问，则判断为垃圾进行回收即可。</p>
<p>引用计数算法逻辑简单，发现垃圾时能立即回收，但是有一个限制：无法回收循环引用的对象。类似上文实例中的<code>obj.left</code>和<code>obj.right</code>一样。而且引用计数算法由于需要实时修改对象的引用数目，时间开销也是相对较大的。</p>
<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>由于引用计数算法的循环引用限制和时间开销大的缺点，标记清除算法通过标记活动对象和清除标记两个阶段对象垃圾进行回收：</p>
<ul>
<li>思想：分为标记活动对和清除未标记对象两个阶段</li>
<li>步骤：遍历所有对象并标记可达（活动）对象；遍历所有对象清除没有标记的对象；回收内存空间。</li>
</ul>
<p>标记清除算法解决了引用计数算法中循环引用不能被清除的问题，但标记清除算法也存在一定缺陷，在清除阶段结束后，回收的空间会放到空闲列表中以供下次申请使用，但是这些回收的空间往往是<strong>内存地址不连续的</strong>，也就是<strong>空间碎片化的问题</strong>，当我们下次再申请空间地址时，如果空闲列表中回收的某块空间大小刚好满足就能正常使用，如果小于申请的空间，就需要重新申请新的地址空间，也就造成了空闲列表的浪费，这样回收到的空间如果不能再次被使用也就失去了意义。</p>
<h4 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h4><p>标记整理算法是标记清除算法的一种增强算法，由于标记清除算法存在空间碎片化的问题，标记整理算法同样是分为标记和清除阶段，只不过，标记整理算法再清除阶段<strong>增加了移动对象位置</strong>的操作，所以清除阶段我们称为整理阶段，这样，碎片化的地址通过位置移动整理：移动活动对象地址，让内存地址变得连续，这样回收之后的地址也就变得连续起来。</p>
<h2 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h2><blockquote>
<p>V8是用C ++编写的Google开源高性能JavaScript和WebAssembly引擎。它用于Chrome和Node.js等。它实现<a href="https://tc39.es/ecma262/">ECMAScript</a>和<a href="https://webassembly.github.io/spec/core/">WebAssembly</a>，并在Windows 7或更高版本，macOS 10.12+和使用x64，IA-32，ARM或MIPS处理器的Linux系统上运行。V8可以独立运行，也可以嵌入到任何C ++应用程序中。</p>
</blockquote>
<h3 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h3><p>V8的采用<strong>分带回收</strong>的的思想：<strong>将内存分为新生代和老生代，针对不同分类采取不同的垃圾回收算法。</strong>即V8会将内存一份为二，一部分存储新生代对象，一部分存储老生代对象，而不同的存储区采用不同的GC算法进行针对性回收。</p>
<p> 一般<strong>新生代对象</strong>指存活时间较短的对象，一般存储在小空间中，采用复制算法和标记整理算法：新生代内存区会分为两个等大的内存空间，使用空间为<code>From</code>,空闲空间为<code>To</code>,活动对象存储在<code>From</code>中，当进行标记整理后将活动对象从<code>From</code>拷贝至<code>To</code>空间，然后就可以直接释放<code>From</code>中拷贝的标记对象，以此达到空间释放的效果。</p>
<p>值得注意的是，如果一些新生代对象在进过一轮GC操作之后还存活着，或者<code>TO</code> 使用率已经达到了<code>25%</code>，那么新生代对象将不再拷贝至<code>To</code>空间，而是直接拷贝到老生代空间，这种现象称为<strong>晋升</strong>。</p>
<p>而老生代区域存在内存限制，比如64位操作系统中为1.4G，32为操作系统中为700M左右。老生代对象主要采用标记清除、标记整理和增量标记算法进行垃圾回收：使用标记清除算法进行高效率的垃圾空间回收，适当采用标记整理算法进行空间优化，当内存空间出现不足时，再使用增量标记算法进行效率优化。</p>
<p>可以发现，新生代区域的垃圾回收主要采用空间换时间的思维，由于新生代区域存货时间段且占用内存小，直接拷贝再清除能提回收效率，而老生代就不再适用复制算法。</p>
<p>注：上面提到的增量标记算法其实是在程序执行中插入<strong>片段化</strong>的标记算法，而不是一次性的GC算法，即标记操作和程序执行<strong>短暂交替执行</strong>，这样就避免整个GC回收过程过长的问题，而拆分为片段化的执行。</p>
<h2 id="Peformance工具"><a href="#Peformance工具" class="headerlink" title="Peformance工具"></a>Peformance工具</h2><p>GC的回收目的其实就是为了实现内存空间的良性循环，但GC都是隐式执行的，程序员并不能感知到内存的变化，而Chrome的<code>Perfomance</code>工具就能为我们监控内存的变化，让我们更好地分析程序执行时内存变化是否异常。</p>
<p><img data-src="/images/performance_tool.png" alt="performance_tool"></p>
<h3 id="存在内存问题的表现"><a href="#存在内存问题的表现" class="headerlink" title="存在内存问题的表现"></a>存在内存问题的表现</h3><ul>
<li>页面出现延迟加载或经常性暂停</li>
<li>页面持续性出现糟糕的性能</li>
<li>页面性能随时间延长越来越差</li>
</ul>
<h3 id="监控内存的方法"><a href="#监控内存的方法" class="headerlink" title="监控内存的方法"></a>监控内存的方法</h3><p>界定内存问题的标准：</p>
<ul>
<li>内存泄漏：内存使用持续升高</li>
<li>内存膨胀：在多数设备上都存在性能问题</li>
<li>频繁垃圾回收：通过内存变化图进行监控分析</li>
</ul>
<p>监控内存变化的方式一般有：</p>
<ul>
<li>浏览器任务管理器</li>
<li><code>Timeline</code>时序图记录</li>
<li>堆快照查找分离DOM</li>
<li>判断是否存在频繁的垃圾回收</li>
</ul>
<h3 id="使用任务管理器监控内存"><a href="#使用任务管理器监控内存" class="headerlink" title="使用任务管理器监控内存"></a>使用任务管理器监控内存</h3><p>浏览器开发者工具中，可以找到任务管理器这一工具，打开是这样的界面：</p>
<p><img data-src="/images/Snipaste_2020-10-12_08-00-21.png"></p>
<p>这是按照打开的标签页进行记录的，如果不存在<code>jsvascript内存</code>列，可以右键显示。</p>
<p>任务管理器需要关注两列数据：内存和JavaScript内存，前者是界面的原生内存，而后者就是JavaScript代码执行占用的内存，我们需要关注的是括号里的实时内存变化，观察jsvaScript实时内存是否存在持续增高而不会出现下降的内存变化。</p>
<h3 id="使用Timeline记录内存变化"><a href="#使用Timeline记录内存变化" class="headerlink" title="使用Timeline记录内存变化"></a>使用Timeline记录内存变化</h3><p>使用<code>timeLine</code>可以更准确地记录内存变化的时序图，我们打开<code>perfomance</code>工具进行界面录制即可展示录制期间的内存变化。</p>
<p>我们先模拟一个内存开销的界面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&#x27;X-UA-Compatible&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;IE=edge&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;viewport&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;width=device-width, initial-scale=1&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> addBtn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;add&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> arr = [];</span></span><br><span class="line"><span class="javascript">        addBtn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 大批量创建dom</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1e5</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>));</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="comment">// 大数组的使用</span></span></span><br><span class="line"><span class="javascript">            arr.push(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1e5</span>).join(<span class="string">&#x27;-&#x27;</span>));</span></span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们打开网页并点击录制按钮，然后正常点击界面的<code>添加</code>按钮，让内存开始变化，测试完成后停止录制就得到下面的时序图：（我们只需要勾选需要展示的内容，让界面更简洁）：</p>
<p><img data-src="/images/image-20201012082130828.png"></p>
<p>如果时序图内存变化<strong>有升有降</strong>，就是正常的，如果<strong>只升不降</strong>或持续升高说明代码可能存在内存泄漏，需要调整测试阶段的代码执行逻辑。</p>
<h3 id="堆快照查找分离DOM"><a href="#堆快照查找分离DOM" class="headerlink" title="堆快照查找分离DOM"></a>堆快照查找分离DOM</h3><p>堆快照也是performance工具中的一个功能，可以截取某个时间点的js堆内存快照。使用堆快照我们可以用于分析js堆中是否存在不合理的内存数据。</p>
<p>比如<code>分离DOM</code>就是一种内存的浪费，DOM一般分为三种状态：</p>
<ul>
<li>存活在DOM树上的界面元素</li>
<li>垃圾对象时的DOM节点：脱离了DOM树，又未引用到的垃圾</li>
<li>分离状态的DOM节点：<strong>不存在DOM树，但有引用</strong></li>
</ul>
<p>分离dom由于被js引用而不能当做垃圾回收，这时，我们可以通过堆快照来分析是否存在分离DOM，如果存在，我们就可以优化相应产生分离DOM的代码。</p>
<p>现在我们简单的模拟产生分离DOM的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>我们打开工具栏的<code>内存</code>选项卡，再点击左侧的录制按钮即可拍下当前堆内存快照：</p>
<p><img data-src="/images/image-20201015215629509.png"></p>
<blockquote>
<p>使用<code>detached</code>可以快速检索到对应的分离内存。</p>
</blockquote>
<h3 id="判断是否存在频繁GC"><a href="#判断是否存在频繁GC" class="headerlink" title="判断是否存在频繁GC"></a>判断是否存在频繁GC</h3><p>GC工作时程序是停止状态的，频发的垃圾回收会导致应用假死，用户体验不佳。</p>
<p>我们可以通过观察<code>Timeline</code>是否存在频繁的内存变化（上升下降），或者通过观察任务管理器中的数据是否存在频繁的增加减小来判断是否存在频繁的GC操作。</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><h3 id="使用jsperf测试js性能"><a href="#使用jsperf测试js性能" class="headerlink" title="使用jsperf测试js性能"></a>使用jsperf测试js性能</h3><p><a href="https://github.com/jsperf/jsperf.com">jsper-github</a></p>
<h3 id="慎用全局变量"><a href="#慎用全局变量" class="headerlink" title="慎用全局变量"></a>慎用全局变量</h3><ul>
<li>全局变量定义在全局执行上下文，是所有作用域的顶端</li>
<li>全局执行上下文会一直存在上下文执行栈中，直到程序退出</li>
<li>如果某个局部作用域出现的同名变量会很容易污染全局变量</li>
</ul>
<h3 id="缓存全局变量"><a href="#缓存全局变量" class="headerlink" title="缓存全局变量"></a>缓存全局变量</h3><p>如果某些地方不得不使用全局变量，我们可以使用局部缓存全局变量的方式进行性能优化。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">    name: <span class="string">&#x27;jinx&#x27;</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> name = config.name; <span class="comment">// 在频繁调用的地方，缓存全局变量</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过原型链新增方法"><a href="#通过原型链新增方法" class="headerlink" title="通过原型链新增方法"></a>通过原型链新增方法</h3><p>测试表明，通过原型链新增方法比内部构造新增速度要更快。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;内部构造的方式新增函数&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">fn2.prototype.foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;通过原型链增加新函数&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for循环的优化"><a href="#for循环的优化" class="headerlink" title="for循环的优化"></a>for循环的优化</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [];</span><br><span class="line">arr[<span class="number">10000</span>] = <span class="string">&#x27;1111&#x27;</span></span><br><span class="line"><span class="comment">// 一般</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) <span class="built_in">console</span>.log(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化写法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length - <span class="number">1</span>; i; i --) <span class="built_in">console</span>.log(i)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">JavaScript内部管理 - MDN</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27628685">认识 V8 引擎 - 知乎</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>性能优化</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode算法题之日期间隔天数</title>
    <url>/2020/08/24/LeetCode%E7%AE%97%E6%B3%95%E9%A2%98%E4%B9%8B%E6%97%A5%E6%9C%9F%E9%97%B4%E9%9A%94%E5%A4%A9%E6%95%B0/</url>
    <content><![CDATA[<p>一道来自<a href="https://leetcode-cn.com/">LeetCode</a>的算法题。</p>
<blockquote>
<p><strong>难度</strong>：简单</p>
<p><strong>来源</strong>：<a href="https://leetcode-cn.com/problems/number-of-days-between-two-dates/">https://leetcode-cn.com/problems/number-of-days-between-two-dates/</a></p>
<p><strong>题目</strong>：请你编写一个程序来计算两个日期之间隔了多少天。日期以字符串形式给出，格式为 <code>YYYY-MM-DD</code>。（注：给定的日期是 <code>1971</code> 年到 <code>2100</code> 年之间的有效日期）</p>
</blockquote>
<a id="more"></a>

<h2 id="待实现模板"><a href="#待实现模板" class="headerlink" title="待实现模板"></a>待实现模板</h2><p><strong>typescript</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">daysBetweenDates</span>(<span class="params">date1: <span class="built_in">string</span>, date2: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>python</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">daysBetweenDates</span>(<span class="params">self, date1, date2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type date1: str</span></span><br><span class="line"><span class="string">        :type date2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="分析-amp-示例"><a href="#分析-amp-示例" class="headerlink" title="分析&amp;示例"></a>分析&amp;示例</h2><p><strong>示例1：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：date1 = &quot;2019-06-29&quot;, date2 = &quot;2019-06-30&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：date1 = &quot;2020-01-15&quot;, date2 = &quot;2019-12-31&quot;</span><br><span class="line">输出：15</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>计算天数间隔，我们可以以给定的最小日期<code>1971.1.1</code>为基准，分别计算给定日期经过了多少天，这样两者相减的绝对值就是间隔天数了。</p>
<p>关键的部分在于如何计算出从<code>1971.1.1</code>到给定日期经过了多少天，一种方法是从给定日期，一天一天递减，直到<code>1971.1.1</code>，但这样比较<strong>简单粗暴</strong>，我们可以找到一些规律来节约我们的计算：每个月的天数是固定的，或者说每年的天数是固定的，除了闰年2月多一天，有了这个规律，我们就可以直接递减年份来计算，而不必一天一天递减。</p>
<p>注：闰年指能被<code>4</code>整除但又不能被<code>100</code>整除的年份，除了能被<code>400</code>整除的世纪闰年。</p>
<h2 id="实现-TypeScript"><a href="#实现-TypeScript" class="headerlink" title="实现(TypeScript)"></a>实现(TypeScript)</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">daysBetweenDates</span>(<span class="params">date1: <span class="built_in">string</span>, date2: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> d1 = getDays(date1);</span><br><span class="line">    <span class="keyword">let</span> d2 = getDays(date2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(d1 - d2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDays</span>(<span class="params">str: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = str.split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> year = <span class="built_in">parseInt</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">let</span> month = <span class="built_in">parseInt</span>(arr[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">let</span> day = <span class="built_in">parseInt</span>(arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">let</span> months = [<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]; <span class="comment">// 365</span></span><br><span class="line">    <span class="keyword">const</span> startY = <span class="number">1971</span>,</span><br><span class="line">        startM = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 日</span></span><br><span class="line">    <span class="keyword">let</span> allDays = day;</span><br><span class="line">    <span class="comment">// 月</span></span><br><span class="line">    <span class="keyword">if</span>(month &gt; <span class="number">2</span> &amp;&amp; isLeapYear(year))&#123;</span><br><span class="line">        allDays += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; month; i++)&#123;</span><br><span class="line">        allDays += months[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 年</span></span><br><span class="line">    <span class="keyword">while</span>(year &gt; startY)&#123;</span><br><span class="line">        allDays += <span class="number">365</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeapYear(--year)) &#123;</span><br><span class="line">            allDays += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allDays;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLeapYear</span>(<span class="params">year: <span class="built_in">number</span></span>): <span class="title">boolean</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (year % <span class="number">4</span> === <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || (year % <span class="number">400</span> === <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现（Python）"><a href="#实现（Python）" class="headerlink" title="实现（Python）"></a>实现（Python）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">daysBetweenDates</span>(<span class="params">self, date1, date2</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type date1: str</span></span><br><span class="line"><span class="string">        :type date2: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> abs(self.getDays(date1) - self.getDays(date2));</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLeapYear</span>(<span class="params">self, year</span>):</span></span><br><span class="line">        <span class="keyword">return</span> (year % <span class="number">400</span> == <span class="number">0</span>) <span class="keyword">or</span> (year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getDays</span>(<span class="params">self, date</span>):</span></span><br><span class="line">        dataArr = date.split(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        year = int(dataArr[<span class="number">0</span>]);</span><br><span class="line">        month = int(dataArr[<span class="number">1</span>]);</span><br><span class="line">        allDays = int(dataArr[<span class="number">2</span>]); <span class="comment"># 日</span></span><br><span class="line">        months = [<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>];</span><br><span class="line">        <span class="keyword">if</span> month &gt; <span class="number">2</span> <span class="keyword">and</span> self.isLeapYear(year):</span><br><span class="line">            allDays += <span class="number">1</span>;</span><br><span class="line">        <span class="comment"># 月</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> month &gt; i:</span><br><span class="line">            allDays += months[i]</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        <span class="comment"># 年</span></span><br><span class="line">        <span class="keyword">while</span> year &gt; <span class="number">1971</span>:</span><br><span class="line">            year -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> self.isLeapYear(year):</span><br><span class="line">                allDays += <span class="number">1</span>;</span><br><span class="line">            allDays += <span class="number">365</span>;</span><br><span class="line">        <span class="keyword">return</span> allDays;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>前端脚手架工具构建</title>
    <url>/2020/10/20/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>脚手架在建筑学中用于保障施工时能稳定进行的平台，建造者会在施工前根据不同的建筑物搭建不同的脚手架以供施工时的重复使用。</p>
<p>前端工程中的脚手架也是一样的道理，很多前端项目都有一些基础文件或通用模块作为项目运行的基本结构和运行工具，前端脚手架能为我们快速开启一个前端工程而<strong>准备好基本的目录结构和基础文件</strong>。</p>
<p>像常见的<code>Vue-cli</code>，<code>React-cli</code>就是专门针对各自框架使用的脚手架工具。本文就另一款通用的脚手架工具<code>yeoman</code>进行简单的使用说明。</p>
<p><img data-src="/images/illustration-home-inverted.91b07808be.png"></p>
<a id="more"></a>

<h2 id="Yeoman的简单使用"><a href="#Yeoman的简单使用" class="headerlink" title="Yeoman的简单使用"></a>Yeoman的简单使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://yeoman.io/">官网</a>定位的<code>yeoman</code>为用于现代WEB应用程序的WEB脚手架工具。<code>yeoman</code>在使用时需要选择不同的生成器模块<code>generator</code>进行不同项目的脚手架搭建，比如官网提供了可用于<a href="https://github.com/yeoman/generator-angular">Angular</a>，<a href="https://github.com/yeoman/generator-backbone">Backbone</a>，<a href="https://github.com/newtriks/generator-react-webpack">React</a>，<a href="https://github.com/yeoman/generator-polymer">Polymer</a>和超过<a href="https://yeoman.io/generators/">5600多个其他项目</a>的脚手架生成器模块。</p>
<p>当然我们也可以利用官方提供的<code>api</code>定义自己的脚手架生成器。</p>
<blockquote>
<p>Yeoman与语言无关。它可以使用任何语言（Web，Java，Python，C＃等）生成项目。</p>
<p>Yeoman本身不做任何决定。每个决定都是由<em>生成器</em>决定的，<em>生成器</em>基本上是Yeoman环境中的插件。有<a href="https://yeoman.io/generators/">很多公开可用的生成器</a>，它很容易<a href="https://yeoman.io/authoring/">创建新的</a><a href="https://yeoman.io/generators/">生成器</a>以匹配任何工作流程。约曼始终是满足您脚手架需求的正确选择。</p>
</blockquote>
<p>脚手架的搭建的一般过程为：</p>
<ol>
<li>明确你的项目需求：需要什么样的脚手架</li>
<li>找到合适的generator</li>
<li>全局安装需要的generator</li>
<li>通过<code>yo</code>模块运行使用的generator</li>
<li>填写generator安装时需要的信息</li>
<li>生成项目基本结构</li>
</ol>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>更具上面的脚手架搭建过程，我们一步一步来。</p>
<ol>
<li><p>全局安装<code>yeoman</code>模块包<code>yo</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm insatll yo -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局安装需要的生成器模块：比如<code>node</code>环境通用的生成器<code>generator-node</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install generator-node -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要创建脚手架的目录执行安装命令：(注：省略前缀<code>generator-</code>)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yo node</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装的过程中生成器可能需要读取用户的一些基本信息：根据你的需求来填写即可</p>
</li>
<li><p>生成对应的项目目录结构：</p>
<p><img data-src="/images/image-20201018220914278.png"></p>
</li>
</ol>
<p>这样我们就可以在这个基础文件结构下快速开始我们的项目啦。</p>
<p>更多细节可参考<a href="https://yeoman.io/learning/index.html">官方使用文档</a>。</p>
<h3 id="sub-generator的使用"><a href="#sub-generator的使用" class="headerlink" title="sub-generator的使用"></a>sub-generator的使用</h3><p>有时候使用到的生成器无法满足我们的需求，这个时候还可以使用该生成器提供的<strong>子生成器</strong><code>sub-generator</code>进行特定的文件或模块补充。该生成器具体支持哪些子生成器需要查看官方说明，比如<code>generator-node</code>支持的子生成器有：</p>
<ul>
<li><code>node:boilerplate</code></li>
<li><code>node:cli</code></li>
<li><code>node:editorconfig</code></li>
<li><code>node:eslint</code></li>
<li><code>node:git</code></li>
<li><code>node:readme</code></li>
</ul>
<p>比如我们需要把刚才的node项目编程cli项目，就可以安装<code>node:cli</code>子生成器来构建一些基本文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yo node:cli</span><br></pre></td></tr></table></figure>

<h3 id="自定义generator"><a href="#自定义generator" class="headerlink" title="自定义generator"></a>自定义generator</h3><p>如果官方提供的生成器无法满足项目的需要，我们就可以自定义一个专门为自己项目服务的生成器对象。</p>
<p>生成器的本质就是一个<code>node-module</code>。</p>
<ol>
<li><p>命名：首先，为你即将写的 generator 创建一个文件夹。这个文件夹必须命名为 <code>generator-name</code> (这里的 <code>name</code> 就是你 generator 的名字)。这是很重要的，作为 Yeoman 的依赖文件系统来查找可用的 generators。比如，我们创建一个名为<code>generator-sample</code>的生成器。</p>
</li>
<li><p>初始化：进入创建好的生成器文件目录，进行<code>npm</code>初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>你应该确保你设置了最新版本的 <code>yeoman-generator</code> 作为一个依赖。你可以去运行：<code>npm install --save yeoman-generator</code>。<code>package.json</code>文件的“file” 属性必须是由你的 generator 使用的文件排列和目录。根据需要加入其他的 <a href="https://docs.npmjs.com/files/package.json#files"><code>package.json</code> 属性</a>。</p>
</li>
<li><p>文件结构：在一个示例项目中，目录树可能看起来像这样：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">├───package.json</span><br><span class="line">├───app/</span><br><span class="line">│   └───index.js</span><br><span class="line">└───router/</span><br><span class="line">    └───index.js</span><br></pre></td></tr></table></figure>

<p>当你使用 <code>yo name</code> 为这个 <code>app</code> 的 generator时，这个默认的 generator 将会被使用。这必须包含在 <code>app/</code> 目录中。</p>
<p>当你使用 <code>yo name:subcommand</code> 时 Sub-generators 将被使用，存储在文件夹中，名字完全像一个子命令。</p>
<p>如果不喜欢把文件都放在根目录，也可以这样：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">├───package.json</span><br><span class="line">└───generators/</span><br><span class="line">    ├───app/</span><br><span class="line">    │   └───index.js</span><br><span class="line">    └───router/</span><br><span class="line">        └───index.js</span><br></pre></td></tr></table></figure>

<p>但<code>file</code>属性需要做对应调整：（目前版本<code>4.12.0</code>不写也能自动读取到）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;generators/app&quot;</span>,</span><br><span class="line">    <span class="string">&quot;generators/router&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写生成器逻辑代码。当文件目录结构确定下来以后，你就可以编写生成器需要实现的功能代码，yeoman提供了一个基本的generator，完成了大部分基本的通用任务，你可在此基础上扩展自己的需求：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generators = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>); <span class="comment">// yeoman提供的生成器基类：能帮我们完成大部分基本工作</span></span><br><span class="line"><span class="built_in">module</span>.exports = generators.Base.extend(&#123;</span><br><span class="line">    method1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;method1 just ran.&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    method2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;method2 just ran.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者使用一个类进行继承：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generators = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">generators</span> </span>&#123;</span><br><span class="line">    <span class="comment">// yeoman-generator 在生成文件阶段会自动调用，这里尝试写入一些东西</span></span><br><span class="line">    writing() &#123;</span><br><span class="line">        <span class="built_in">this</span>.fs.write(</span><br><span class="line">            <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;readme.txt&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;this is a generator-sample demo&#x27;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行：当导出了一个基本的模块，其实最基本的一个生成器已经实现了，现在我们来运行（使用）我们自己定义的生成器模块：</p>
<p>首先使用<code>npm link</code>将该模块链接到全局，以便能直接使用。</p>
<p>然后在使用目录下执行：<code>yo sample</code>即可。如果，控制台打印了我们扩展的两个函数的信息，说明执行成功了。</p>
</li>
</ol>
<p>更多使用细节请参考<a href="https://yowebapp.github.io/authoring/index.html">官方文档</a>。</p>
<h3 id="自定义生成器：创建模板文件"><a href="#自定义生成器：创建模板文件" class="headerlink" title="自定义生成器：创建模板文件"></a>自定义生成器：创建模板文件</h3><p>有时候我们需要生成多个文件，或者需要根据一些变量来动态创建文件，这个时候就需要使用到模板文件，generator里的模板文件使用的是<code>ejs</code>的模板文件语法。模板文件默认放到<code>./templates</code>目录下。</p>
<blockquote>
<p>模板上下文默认被定义为<code>./templates/</code>。你可以使用<code>generator.sourceRoot(&#39;new/template/path&#39;)</code>去重写这个默认值。</p>
</blockquote>
<p>首先，我们随便创建一个模板文件，如readme.txt：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">这是一个模板文件</span><br><span class="line">内部可以使用EJS模板标记语法：</span><br><span class="line">&lt;%= title %&gt;</span><br><span class="line">或者使用EJS语法：</span><br><span class="line">&lt;% if(success) &#123; %&gt;</span><br><span class="line">成功输出！</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以使用模板文件来动态创建文件了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generators = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">generators</span> </span>&#123;</span><br><span class="line">    writing() &#123;</span><br><span class="line">        <span class="comment">// 模板文件路径</span></span><br><span class="line">        <span class="keyword">const</span> temp = <span class="built_in">this</span>.templatePath(<span class="string">&#x27;readme.txt&#x27;</span>);</span><br><span class="line">        <span class="comment">// 输出路径</span></span><br><span class="line">        <span class="keyword">const</span> output = <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;readme.txt&#x27;</span>);</span><br><span class="line">        <span class="comment">// 模板上下文数据</span></span><br><span class="line">        <span class="keyword">const</span> data = &#123;</span><br><span class="line">            title: <span class="string">&#x27;follow your heart.&#x27;</span>,</span><br><span class="line">            success: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制并渲染模板文件</span></span><br><span class="line">        <span class="built_in">this</span>.fs.copyTpl(temp, output, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="自定义生成器：与用户交互"><a href="#自定义生成器：与用户交互" class="headerlink" title="自定义生成器：与用户交互"></a>自定义生成器：与用户交互</h3><p>在上面的模板中，一般需要动态太如的都是来自用户输入的数据，所以有必要接受用户输入数据来动态创建文件。</p>
<p>要提示用户输入并获取数据，我们需要实现<code>prompting</code>接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generators = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">generators</span> </span>&#123;</span><br><span class="line">    prompting()&#123;</span><br><span class="line">        <span class="comment">// 定义用户输入数据的问题和默认值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.prompt([&#123;</span><br><span class="line">            type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">            message : <span class="string">&#x27;Your project name&#x27;</span>,</span><br><span class="line">            <span class="keyword">default</span> : <span class="built_in">this</span>.appname <span class="comment">// Default to current folder name</span></span><br><span class="line">        &#125;]).then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.answers = answers; <span class="comment">// 用户输入数据的键值对</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writing() &#123;</span><br><span class="line">        <span class="comment">// 模板文件路径</span></span><br><span class="line">        <span class="keyword">const</span> temp = <span class="built_in">this</span>.templatePath(<span class="string">&#x27;readme.txt&#x27;</span>);</span><br><span class="line">        <span class="comment">// 输出路径</span></span><br><span class="line">        <span class="keyword">const</span> output = <span class="built_in">this</span>.destinationPath(<span class="string">&#x27;readme.txt&#x27;</span>);</span><br><span class="line">        <span class="comment">// 模板上下文数据</span></span><br><span class="line">        <span class="keyword">const</span> answers = <span class="built_in">this</span>.answers; <span class="comment">// 使用用户输入数据</span></span><br><span class="line">        <span class="keyword">const</span> data = &#123;</span><br><span class="line">            title: answers[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">            success: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制并渲染模板文件</span></span><br><span class="line">        <span class="built_in">this</span>.fs.copyTpl(temp, output, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发布自定义generator"><a href="#发布自定义generator" class="headerlink" title="发布自定义generator"></a>发布自定义generator</h3><p>为了方便后续更方便地使用我们创建好的generator，可以将生成器模块公开发布到npm上。这里的发布流程与普通的npm模块发布无异。</p>
<ol>
<li><p>创建本地git仓库,并将代码推送到github远程仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">忽略node_modules文件夹</span></span><br><span class="line">echo node_modules &gt; .gitignore</span><br><span class="line"><span class="meta">#</span><span class="bash">git初始化</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash">提交本地记录</span></span><br><span class="line">git add.</span><br><span class="line">git commit -m &quot;generator init&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">在github上创建仓库并完成绑定</span></span><br><span class="line">git remote add origin https://github.com/fongzhizhi/generator-sample.git</span><br><span class="line"><span class="meta">#</span><span class="bash">提交到master分支</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
</li>
<li><p>将模块发布到npm</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果你的npm仓库绑定了淘宝镜像等仓库地址，需要在发布时指定官方仓库</span></span><br><span class="line">npm publish --registry=ttps://registry.npmjs.org/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">3. 然后就能在npm官网搜索到你发布的模块了</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;shell</span><br><span class="line">   #这里为了测试，所以我们不是真正发布一个模块，测试成功后移除即可</span><br><span class="line">   npm unpublish</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Plop的简单使用"><a href="#Plop的简单使用" class="headerlink" title="Plop的简单使用"></a>Plop的简单使用</h2><p>一款小而美的脚手架工具，<a href="https://github.com/plopjs/plop">github地址</a>。我们可以使用Plop通过模板文件为我们批量生成文件，就像yeoman那样。</p>
<h2 id="脚手架的工作原理"><a href="#脚手架的工作原理" class="headerlink" title="脚手架的工作原理"></a>脚手架的工作原理</h2><p>脚手架本质上就是一个创建文件的node-cli应用，至于需要创建什么样的文件，就取决于我们的项目性质是什么，通过脚手架创建的基础文件就能快速开始我们的项目，而无需重复性地创建文件或导入一些通过模块。</p>
<p>首先，我们新建一个文件夹，创建一个node模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir scaffloding-sample</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>作为Node CLI应用，我们使用<code>cli.js</code>作为模块执行的入口文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node CLI 应用入口文件必须要有这样的文件头</span></span><br><span class="line"><span class="comment">// 在Linux 或 macOS系统中还需要将此文件的读写权限修改为755 ： chmod 755 cli.js </span></span><br></pre></td></tr></table></figure>

<p>然后，修改<code>package.json</code>文件的<code>bin</code>字段为<code>cli.js</code>。</p>
<p>现在，我们就来编写<code>cli.js</code>逻辑了，一般来说，脚手架最基本的两个功能：</p>
<ul>
<li>用户交互：我们使用<code>inquirer</code>模块进行实现。</li>
<li>生成模板文件：我们使用<code>ejs</code>模板引擎进行渲染。</li>
</ul>
<p>现在我们随便创建一些模板文件，比如<code>templates/index.html</code>，<code>templates/main.css</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&#x27;X-UA-Compatible&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;IE=edge&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">name</span> %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;viewport&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;width=device-width, initial-scale=1&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&#x27;stylesheet&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;text/css&#x27;</span> <span class="attr">media</span>=<span class="string">&#x27;screen&#x27;</span> <span class="attr">href</span>=<span class="string">&#x27;./main.css&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">name</span> %&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#cecece</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要是为了测试，就不写太多东西。</p>
<p>那么<code>cli.js</code>的逻辑就可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Node CLI 应用入口文件必须要有这样的文件头</span></span><br><span class="line"><span class="comment">// 在Linux 或 macOS系统中还需要将此文件的读写权限修改为755 ： chmod 755 cli.js </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * [脚手架的一般功能]</span></span><br><span class="line"><span class="comment"> * 1.用户交互：根据使用者的信息来生成不同的文件配置 =&gt; inquire模块来实现</span></span><br><span class="line"><span class="comment"> * 2.使用模板引擎生成模板文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> inuqire = <span class="built_in">require</span>(<span class="string">&#x27;inquirer&#x27;</span>); <span class="comment">// 用户交互模块</span></span><br><span class="line"><span class="keyword">const</span> ejs = <span class="built_in">require</span>(<span class="string">&#x27;ejs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; connect &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">inuqire.prompt([&#123;</span><br><span class="line">    type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    message: <span class="string">&#x27;the project name:&#x27;</span>,</span><br><span class="line">    <span class="keyword">default</span>: <span class="string">&#x27;my-project&#x27;</span>,</span><br><span class="line">&#125;]).then(<span class="function"><span class="params">anwser</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 根据用户信息生成文件</span></span><br><span class="line">    <span class="comment">// 模板目录</span></span><br><span class="line">    <span class="keyword">const</span> tempDir = path.join(__dirname, <span class="string">&#x27;templates&#x27;</span>)</span><br><span class="line">    <span class="comment">// 目标目录</span></span><br><span class="line">    <span class="keyword">const</span> destDir = process.cwd();</span><br><span class="line">    <span class="comment">// 读取模板文件目录下的所有文件</span></span><br><span class="line">    fs.readdir(tempDir, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 使用模板引擎读取文件</span></span><br><span class="line">            ejs.renderFile(path.join(tempDir, file), anwser, <span class="function">(<span class="params">err, content</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">                <span class="comment">// 写入文件</span></span><br><span class="line">                fs.writeFileSync(path.join(destDir, file), content);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>现在，我们使用<code>npm link</code>将模块链接到全局，就可以通过命令行使用这个cli模块了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scaffloding-sample</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>工程化</tag>
        <tag>脚手架</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript异步编程</title>
    <url>/2020/09/20/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>由于JavaScript的主要API为<code>DOM</code>相关的操作，所以JavaScript设计为一门以<strong>单线程</strong>模式运行的语言，即<strong>JavaScript执行代码的线程只有一个</strong>。这样可以避免多线程复杂同步的问题，代码逻辑也更安全、简洁。</p>
<p>但是单线程的缺点也很明显，代码执行的任务都是队列执行的，当遇到耗时的操作时，后续任务不得不等待耗时任务的执行，对于web页面来说，常常造成假死的现象。</p>
<p>单线程模式下，为了<strong>避免耗时任务阻塞</strong>主线程的执行，JavaScript还支持同步模式和异步模式，对此，本文梳理了<code>js</code>中异步模式的基本使用和常用异步方案。</p>
<p><img data-src="/images/async.png" alt="async"></p>
<a id="more"></a>

<h2 id="线程和进程-amp-同步和异步"><a href="#线程和进程-amp-同步和异步" class="headerlink" title="线程和进程 &amp; 同步和异步"></a>线程和进程 &amp; 同步和异步</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>在使用之前，理解其本质才能更好的运用自如。我们先来看一下看一下<strong>线程</strong>和<strong>进程</strong>的基本概念：</p>
<blockquote>
<p><strong>线程</strong>（英语：thread）是<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>能够进行运算<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6">调度</a>的最小单位。大部分情况下，它被包含在<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>之中，是<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>中的实际运作单位。一条线程指的是<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
</blockquote>
<blockquote>
<p><strong>进程</strong>（英语：process），是指计算机中已运行的<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F">程序</a>。在面向线程设计的系统（如当代多数操作系统、<a href="https://zh.wikipedia.org/wiki/Linux">Linux</a> 2.6及更新的版本）中，进程本身不是基本运行单位，而是<a href="https://zh.wikipedia.org/wiki/%E5%9F%B7%E8%A1%8C%E7%B7%92">线程</a>的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。</p>
</blockquote>
<p>可以看出，进程也就是计算机执行中的一项“任务”，而一条线程只是<a href="https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B">进程</a>中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>这就好比一个工厂（电脑）开启了一项新生产任务（程序|进程），按照任务的调度设计，需要10个工人（线程）来进行不同加工处理，最终完成产品的产出（程序执行结果）。</p>
<p>这10个人是不可分割的独立个体，好比线程是操作系统能够运算的最小单位，而10个人的任务组合起来完成了一项生产任务，这个任务我们就称之为进程，就像是一条生产线，我们需要开启、停止，以及安排多少工人进行加工只是程序设计的问题。</p>
<p>在多任务操作系统中，我们就可以并行执行多个程序，这就是为什么我们可以边打游戏边听歌等多程序同时执行，玩游戏和听歌，也就是我们说到应用程序，每个应用程序可以包含多个进程，而多个进程任务又可以各自划分为多个线程来执行。</p>
<p>但是CPU执行代码都是顺序执行的，如何做到多进程同时执行？实际上，早期的单核CPU只是以极快的速度在各个进程之间来回交替执行，速度之快以至于我们感受不到卡顿的感觉，除了当你打开太多应用而CPU处理不过来时你才会感到程序运行的卡顿。而后面出现的多核CPU才是真正的做到了并行执行。</p>
<p>当我们在进行<strong>多任务开发</strong>，或者比较大型且复杂的程序开发时，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务。</p>
<p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
<p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
<p>在开发复杂的应用程序时，我们可以选择多线程模式，也可以选择多进程模式，或者两种结合的模式，这需要根据实际的场景来考虑。</p>
<p><strong>多进程的优点在于稳定性高</strong>，由于进程之间都是比较独立的，某个进程挂掉之后，并不会印象其他进程的的执行，这好比一个公司的多个部门，某个部门瘫痪一般不会造成其他部门的瘫痪。但是线程的创建和管理是<strong>比较消耗系统开销</strong>的，太多的进程会让系统难以调度运行。</p>
<p>而多线程只是单个进程中的一部分，开销只在内部运作，性能提升会好很多，但问题也十分明显，由于同一进程中的多条线程将<strong>共享该进程中的全部系统资源</strong>，如虚拟地址空间，<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6">文件描述符</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86">信号处理</a>等等。但同一进程中的多个线程有各自的<a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88">调用栈</a>（call stack），自己的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%84%E5%AD%98%E5%99%A8%E7%8E%AF%E5%A2%83&action=edit&redlink=1">寄存器环境</a>（register context），自己的线程本地存储（thread-local storage）。这会让某个线程挂掉之后整个进程阻塞乃至结束。就好比一个部门虽说是分工合作的，但如果上一个人的任务没有完成，下一个人就会进入等待|阻塞状态，并可能造成链式阻塞，最终就可能被操作系统强制结束进程。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><blockquote>
<p><strong>同步</strong>（英语：synchronization），是一种线性执行的过程，整个调用需要等待所有结果都返回才结束的过程。</p>
</blockquote>
<blockquote>
<p><strong>异步</strong>（英语：asynchrony）是相对于**<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5">同步</a>**（synchrony）的概念，异步指令的调用者无需等待执行结果而继续执行后续代码的过程，最终返回结果也无需等待异步执行结果。</p>
</blockquote>
<p>举一个生活中的例子，比如你需要打电话办理业务，同步模式就是发起打电话的指令，然后告知业务员需要办理的业务，并等待业务员办理好业务，再挂掉电话。异步模式就是发起了打电话的指令，然后告知业务员需要办理的业务，然后把办理结果通过短信告知你，然后挂掉电话。</p>
<p>这其中的区别在于，办理业务这个过程，需要等待执行就是同步，而只需要把办理结果告知你（回调）就是异步。</p>
<p>我们上面讲到了线程和进程，他们都是互相独立的执行体，而要实现异步，我们就需要开启另外的线程或进程。</p>
<p>我们知道，JavaScript是单线程模式的，但是JavaScript的执行体，比如浏览器并不是单线程的，所以我们说js也支持异步，其实是浏览器支持异步，相当于js的异步操作交给浏览器来执行，后文会更详细地分析js异步执行的原理，这里不再赘述。</p>
<h2 id="js中的同步模式"><a href="#js中的同步模式" class="headerlink" title="js中的同步模式"></a>js中的同步模式</h2><p>同步执行也就是js主线程线性执行的过程，也就是代码一句一句地顺序执行，比如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global begin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;bar runing&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo runing&#x27;</span>)</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果是显而易见的。</p>
<p>js的主线程执行过程可以理解为进栈和出栈的过程。js是单线程，所以这有一个调用栈（Call Stack），我们逐行分析上面的代码：</p>
<blockquote>
<p>入栈相当于加载需要执行的代码，出栈相当于执行代码。</p>
</blockquote>
<p>运行js，执行上面的代码块，上面的代码块其实相当于在执行一个匿名函数，所以首先js使用匿名函数(anonymous)封装这个代码块，</p>
<p>第一步：匿名函数压如调用栈，并开始同步执行（执行函数体内部代码）。</p>
<p>第二步：<code>console.log(&#39;global begin&#39;)</code>入栈，到这里可以<strong>看作</strong>为最小执行语句，出栈。</p>
<p>第三步：加载函数体，但函数体未调用，不需要执行，所以不入栈。</p>
<p>第四步：<code>foo()</code>入栈。<code>foo</code>函数不是最小执行语句，需要进行内部代码块入栈和出栈操作。相当于递归。</p>
<p>第五步：<code>console.log(&#39;foo runing&#39;)</code>代码入栈，然后出栈。</p>
<p>第六步：<code>bar()</code>入栈。</p>
<p>第七步：<code>console.log(&#39;bar running&#39;)</code>入栈，然后出栈。</p>
<p>第八步：<code>foo()</code>函数代码段已经全部出栈（执行）了，<code>foo</code>函数出栈。</p>
<p>第九步：继续入栈，<code>console.log(&#39;global end&#39;)</code>入栈，然后出栈。</p>
<p>第十步：匿名函数执行完毕，出栈。</p>
<p>最后，调用栈已经空了，执行结束，进入等待或结束状态。等待别的函数体或代码入栈，以此达到同步执行的效果。</p>
<p>可以发现，入栈再出栈的过程就保证了代码的执行顺序，先入栈<strong>最小执行代码</strong>的会先执行，后入栈的需要等待前面入栈的代码执行完毕再出栈执行，也就是同步模式的基本实现原理。</p>
<h2 id="js中的异步模式"><a href="#js中的异步模式" class="headerlink" title="js中的异步模式"></a>js中的异步模式</h2><p>异步模式其实可以理解为同步模式过程发起的异步指令，而该指令发送完毕就会出栈，也就是后续代码能立即执行而不必等待异步执行的处理结果。</p>
<p>异步的计算过程会交由别的执行体（其他线程或其他进程）去执行，所以不会占用js的主线程，但执行结果是我们需要关心的，我们需要根据异步函数处理的结果进行后续处理，这就是<strong>回调函数</strong>。回调函数是调用者（js主线程）传给异步函数的一个参数，当异步调用结束之后，异步执行函数会把<strong>回调函数压入js调用栈</strong>中，所以js能在后续处理回调结果。</p>
<p>在js中，同步函数的执行是在js主线程的调用栈中执行，而异步函数相当于在js的调用者提供的api中执行，比如新的线程中执行，两个线程之间通过一个叫<code>消息队列</code>的处理器进行通信，即当异步函数执行结束后会把回调函数交给消息队列，消息队列再把回调函数压入js主线程调用栈中执行。所以多个异步函数执行时，异步函数的回调函数的执行顺序是不确定的，取决于异步函数交给把回调函数交给消息队列的时间。</p>
<p>比如下面的js代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global begin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async callback1....&#x27;</span>) <span class="comment">// 回调函数1</span></span><br><span class="line">&#125;, <span class="number">1800</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async callback2....&#x27;</span>)<span class="comment">// 回调函数2</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;global end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>首先，<code>console.log(&#39;global begin&#39;)</code>入栈，出栈。</p>
<p>然后是异步函数1<code>setTimeout</code>入栈，出栈。</p>
<p>接着是异步函数2<code>setTimeout</code>入栈，出栈。</p>
<p>最后<code>console.log(&#39;global end&#39;)</code>入栈，出栈，调用栈暂时为空，处于等待执行状态。</p>
<p><code>setTimeout</code>是浏览器提供的两个异步api，会在别的线程中执行，进过<code>1s</code>后异步函数2执行完毕，回调函数2进入消息队列，消息队列把回调函数2入栈，再出栈，函数体<code>console.log(&#39;async callback2....&#39;)</code>执行完毕。</p>
<p>再进过<code>0.8s</code>后异步函数1执行结束，回调函数1进入消息队列，并接着被压入js调用栈，再出栈，<code>onsole.log(&#39;async callback1....&#39;)</code>执行完毕。</p>
<p>调用栈再次回到空栈等待状态。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数就是异步函数执行结束之后重新入栈执行的函数，我们调用异步函数最终都需要处理异步之后的回调，否则这个异步就是无意义的。</p>
<p>回调函数是异步函数的根基，但由于回调函数执行顺序的不确定，过多的对调函数会让代码解构变得复杂。</p>
<p>还有一些状态需要使用到回调函数的执行结果，如果一味地往回调中补充调用逻辑，会让回调函数过于复杂，不容阅读且难以维护。</p>
<p>以上这些问题都可以使用js提供的<strong>统一的异步编程方案</strong><code>：Promise对象</code>来解决。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p><strong>Promise</strong>对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。<strong>Promise</strong>对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。</p>
</blockquote>
<p>为了解决异步回调函数嵌套多深的问题，<code>CommonJS</code>社区提出了<code>Promise</code>规范，并在<code>ES2015</code>中被标准化。一个<code>Promise</code>有三种状态：</p>
<ul>
<li><em>pending</em>: 初始状态，既不是成功，也不是失败状态。 =&gt; 异步执行中。</li>
<li><em>fulfilled</em>: 意味着操作成功完成。 =&gt; <code>onFulifilled</code>，执行成功回调。</li>
<li><em>rejected</em>: 意味着操作失败。=&gt; <code>onRejected</code>，执行失败回调。</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个promise对象并发起异步请求</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;padding....&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;success!&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(<span class="string">&#x27;failed!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;progress begin....&#x27;</span>)</span><br><span class="line"><span class="comment">// 接收异步回调结果</span></span><br><span class="line">promise.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;progress end....&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// padding....</span></span><br><span class="line"><span class="comment">// progress begin....</span></span><br><span class="line"><span class="comment">// progress end....</span></span><br><span class="line"><span class="comment">// success!</span></span><br></pre></td></tr></table></figure>

<p>可以发现，<code>Promise</code>对象需要接收一个带有<code>resolve</code>和<code>reject</code>两个参数的函数，用于分别接收异步执行<code>fullfilled</code>和<code>rejected</code>的状态结果。</p>
<p>而异步函数的<code>then</code>函数同样以两个函数为参数，分别对应异步函数的<strong>成功回调</strong>和<strong>失败回调</strong>。</p>
<p>当执行<code>then</code>之后，当回调函数状态由<code>padding</code>变为<code>fullfilled</code>或者<code>rejected</code>，<code>Promise</code>对象就会把对应的回调函数压入消息队列，然后入栈执行。（在上面的例子中，尽管异步函数执行体中没有异步代码，但执行状态结果任然会进入消息队列）。</p>
<h3 id="Promise使用案例：Ajax"><a href="#Promise使用案例：Ajax" class="headerlink" title="Promise使用案例：Ajax"></a>Promise使用案例：<code>Ajax</code></h3><blockquote>
<p>Asynchronous JavaScript + XML（异步JavaScript和XML）, 其本身不是一种新技术，而是一个在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: <a href="https://developer.mozilla.org/en-US/docs/HTML">HTML</a> 或 <a href="https://developer.mozilla.org/en-US/docs/XHTML">XHTML</a>,  <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/CSS">CSS</a>, <a href="https://developer.mozilla.org/en-US/docs/JavaScript">JavaScript</a>, <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">DOM</a>, <a href="https://developer.mozilla.org/en-US/docs/XML">XML</a>, <a href="https://developer.mozilla.org/en-US/docs/XSLT">XSLT</a>, 以及最重要的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>。当使用结合了这些技术的AJAX模型以后， 网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。(尽管X在Ajax中代表XML, 但由于<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/JSON">JSON</a>的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。)</p>
</blockquote>
<p>现在我们使用<code>Promise</code>来实现一个简单的<code>ajax</code>方案。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Promise实现的ajax</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">        xhr.response = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.status === <span class="number">200</span>)&#123;</span><br><span class="line">                resolve(<span class="built_in">this</span>.response);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajax(<span class="string">&#x27; /user.json&#x27;</span>).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>按照传统的回调执行，如果想要队列执行异步函数，我们可能会这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url  = <span class="string">&#x27;/user.json&#x27;</span>;</span><br><span class="line">ajax(url).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    ajax(url).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        ajax(url).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">            ajax(url).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样的嵌套写法是<code>Promise</code>的一种用法误区，这无法体现<code>Promise</code>的优越性，和原本的回调函数无异。而<code>Promise</code>的<code>then</code>方法其实会<strong>返回一个新的Promise对象</strong>，这样我们能就链式执行多个异步函数。就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url  = <span class="string">&#x27;/user.json&#x27;</span>;</span><br><span class="line">ajax(url)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>我们发现，只有第一个回调返回了<code>ajax</code>异步请求的结果，后面的回调虽然执行，但结果都是<code>undefined</code>，这是因为<code>then</code>方法返回的并不是自身的<code>promise</code>对象，而是一个新的<code>Promise</code>对象。这是默认的返回一个新的<code>Promise</code>，我们可以自行指定需要执行的<code>Promise</code>对象，这样，就达到了链式调用的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="keyword">return</span> ajax(url);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="keyword">return</span> ajax(url);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Promise的异常处理"><a href="#Promise的异常处理" class="headerlink" title="Promise的异常处理"></a>Promise的异常处理</h3><p>我们上面已经知道，<code>then</code>函数的第二个参数就是用来处理异步失败结果的回调函数，但是在链式调用中，过多的书写异常函数过于繁杂，所以<code>Promise</code>对象提供了一个<code>catch</code>方法，这个方法会保留链式调用的异常结果给下一个<code>Promise</code>对象，所以我们只需要在链式调用的最后使用<code>catch</code>方法就可以捕获到链式调用中的异常。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="keyword">return</span> ajax(url);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="keyword">return</span> ajax(url);</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果某个链式中的某个异步函数失败了，后续的链式异步就不会再执行了，因为这里的链式都是写在成功回调中的，异步失败后将会打断链式执行的效果。</p>
</blockquote>
<p>实际上，<code>catch(reject)</code>函数本质上相当于<code>then(undefined, reject)</code>，所以，在<code>catch</code></p>
<p>中返回一个新的<code>Peomise</code>对象同样能实现链式调用的效果。（而<code>finally</code>函数总会返回一个新的<code>Promise</code>对象，就算手动指定返回值也不能实现链式效果）。</p>
<h3 id="Promise的静态方法"><a href="#Promise的静态方法" class="headerlink" title="Promise的静态方法"></a>Promise的静态方法</h3><h4 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h4><blockquote>
<p>Promise.resolve()。返回一个新的或者指定的<code>Promise</code>对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = ajax(<span class="string">&#x27;/user.json&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p1)</span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>光是这样这个函数没有什么效果，实际上我们还可以传入任意实现了<code>then</code>方法的对象，然后就能返回一个新的<code>Promise</code>对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;haha&#x27;</span>)</span><br><span class="line">        resolve(<span class="string">&#x27;hehe&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Promise</span>.resolve(p1); <span class="comment">// haha</span></span><br><span class="line"><span class="built_in">console</span>.log(p1 === p2) <span class="comment">// false</span></span><br><span class="line">p2.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val) <span class="comment">// hehe</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种实现了<code>then</code>方法的对象我们称之为实现了<code>thenable</code>接口的对象，都可以转换为一个全新的<code>Promise</code>对象，如果传入的是<code>Promise</code>对象，则直接返回该对象。</p>
<p><code>Promise.resolve</code>的用途在于封装一个实现了<code>thenable</code>接口的对象，早期在<code>Promise</code>对象出现之前，可能有很多自己实现的异步方案，这样我们就能利用这个静态方法将那些异步对象转为<code>Promise</code>对象。</p>
<h4 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h4><blockquote>
<p>同<code>Promise.resolve</code>对象一样，<code>reject</code>函数能让我们快速返回一个失败的<code>Peomise</code>对象。</p>
</blockquote>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>这个方法返回一个新的<code>Promise</code>对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。</p>
<p>假设我们需要<strong>并行执行</strong>多个异步函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(url1).then(...)</span><br><span class="line">ajax(url2).then(...)</span><br><span class="line">ajax(url3).then(...)</span><br></pre></td></tr></table></figure>

<p>但是这样简单的调用我们无法知道所有异步任务是否都已经直接结束，传统的方法是，使用一个计数器来统计，而现在我们使用<code>Promise.all</code>就能达到这个效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要并行执行的Promise函数</span></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">    ajax(<span class="string">&#x27;/user.json&#x27;</span>),</span><br><span class="line">    ajax(<span class="string">&#x27;/post.json&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 使用all进行统计收集</span></span><br><span class="line"><span class="built_in">Promise</span>.all(arr).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> res <span class="keyword">of</span> results)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这样，当迭代器中的<code>Promise</code>的状态<strong>都成功或者有一个失败</strong>就会结束整个异步执行状态。</p>
<p>当然，如果你希望某个异步函数失败后仍然能正常统计执行，可以改用<code>Promise.allSettled</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled(arr).then(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> res <span class="keyword">of</span> results)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，返回的新<code>Promise</code>对象会返回所有异步执行的回调结果，包含了成功和失败的结果。</p>
<p>此外，还有一个<code>Promise.race</code>有类似的用途，区别在于<code>race</code>方法会在iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。即任意一个异步请求结束后就立即返回该对象的结果，而不会等待其余异步结果。（<code>race</code>有比赛、竞赛的含义，意即几个回调函数同步执行，但该方法只接收第一个执行结束的异步函数）。</p>
<h2 id="Generator异步解决方案"><a href="#Generator异步解决方案" class="headerlink" title="Generator异步解决方案"></a>Generator异步解决方案</h2><p>相比传统异步调用，<code>Promise</code>最大的优势就是链式调用更扁平而解决了传统回调嵌套过深的问题。但链式调用过多<strong>相比同步模式</strong>来说还是不易控制和阅读。<code>ES2015</code>提供了生成器函数，利用这个函数，我们能让异步函数拥有同步函数执行的效果。</p>
<p>首先看一个简单生成器函数的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">getNumber</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">yield</span> ++index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> IndexGenerator = getNumber()</span><br><span class="line"><span class="built_in">console</span>.log(IndexGenerator.next().value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(IndexGenerator.next().value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(IndexGenerator.next().value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>生成器最大的特点就是能够利用<code>yield</code>关键字“暂停”函数的执行，当主动调用生成器函数的<code>next</code>方法后才会继续执行后续代码，直到下一个<code>yield</code>函数然后再次暂停。</p>
<p>利用生成器函数的暂停代码特性，我们就可以暂停等待异步函数的回调结果，然后再继续后续代码的执行，以此达到<strong>异步代码同步执行的效果</strong>。</p>
<p>首先我们可以使用生成器函数来实现链式调用的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 异步ajax</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">        xhr.response = <span class="string">&#x27;json&#x27;</span>;</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.status === <span class="number">200</span>)&#123;</span><br><span class="line">                resolve(<span class="built_in">this</span>.response);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">syncAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> p1 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;/user.json&#x27;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(p1) <span class="comment">// undefined</span></span><br><span class="line">   <span class="keyword">const</span> p2 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;/post.json&#x27;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(p2) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;program start...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生成器函数进行链式调用</span></span><br><span class="line"><span class="keyword">const</span> sync_ajax = syncAjax()</span><br><span class="line">sync_ajax.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val); <span class="comment">// ...</span></span><br><span class="line">    sync_ajax.next().value.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(val); <span class="comment">// ...</span></span><br><span class="line">        sync_ajax.next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;program end...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>生成器函数还有一个特点就是，<code>next</code>函数传入的值能返回给<code>yield</code>语句。所以，上面的实例改造一下就变成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">syncAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> p1 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;/user.json&#x27;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(p1) <span class="comment">// 异步1的回调结果</span></span><br><span class="line">   <span class="keyword">const</span> p2 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;/post.json&#x27;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(p2) <span class="comment">// 异步2的回调结果</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 异步生成器的自调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoNext</span>(<span class="params">g, next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (next.done) <span class="keyword">return</span>;</span><br><span class="line">    next.value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        autoNext(g, g.next(data));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用生成器函数进行链式调用</span></span><br><span class="line"><span class="keyword">const</span> g = syncAjax()</span><br><span class="line">autoNext(g, g.next()); <span class="comment">// 递归调用生成器函数内部的所有结果</span></span><br></pre></td></tr></table></figure>

<p>而在<code>syncAjax</code>函数中，<code>p1</code>和<code>p2</code>分别是两个异步函数的回调值，这就这个生成器函数内部变成了同步执行的代码。</p>
<p>我们可以封装为一个工具函数，让一个生成器作为参数传入，并等待生成器函数内部的异步执行结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">syncAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> p1 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;/user.json&#x27;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(p1) <span class="comment">// 异步1的回调结果</span></span><br><span class="line">   <span class="keyword">const</span> p2 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;/post.json&#x27;</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(p2) <span class="comment">// 异步2的回调结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>generator Generator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">syncG</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = generator();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">autoNext</span>(<span class="params">g, next</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next.done) <span class="keyword">return</span>;</span><br><span class="line">        next.value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            autoNext(g, g.next(data));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    autoNext(g, g.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">syncG(syncAjax)</span><br></pre></td></tr></table></figure>

<p>我们观察生成器函数<code>syncAjax</code>内部的代码，已经完全地把异步结果变成了同步结果来执行。而我们只需要使用一个工具函数<code>syncG</code>即可实现，我们在利用生成器函数的<code>throw</code>函数来捕获异常即可完善这个工具函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">syncAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> p1 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;/user.json&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(p1) <span class="comment">// 异步1的回调结果</span></span><br><span class="line">        <span class="keyword">const</span> p2 = <span class="keyword">yield</span> ajax(<span class="string">&#x27;/post1.json&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(p2) <span class="comment">// 异步2的回调结果</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>generator Generator</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = generator();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">autoNext</span>(<span class="params">g, next</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (next.done) <span class="keyword">return</span>;</span><br><span class="line">        next.value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            autoNext(g, g.next(data));</span><br><span class="line">        &#125;, (<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            g.throw(err);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    autoNext(g, g.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(syncAjax)</span><br></pre></td></tr></table></figure>

<p>实际上，很多库已经封装了这个效果，类似<code>co</code>这种库，包括生成器的出现，以及这种工具库其实我们都很少再使用，原因是官方在<code>ES2017</code>中已有类似的实现，而且只需要使用<code>async</code>和<code>await</code>两个关键字即可达到这种效果。</p>
<p>这两个关键字只是官方提供的语法糖而已，内部任然是<code>generator</code>和<code>promise</code>配合<code>yield</code>关键字实现的效果。</p>
<h2 id="Asyn函数"><a href="#Asyn函数" class="headerlink" title="Asyn函数"></a>Asyn函数</h2><p>上面的<code>generator</code>异步编程方案，官方已经提供了更为简单便捷的语法糖关键字：<code>aysnc</code>和<code>await</code>，那么上面的案例只需要写成这样就可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">syncAjax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> p1 = <span class="keyword">await</span> ajax(<span class="string">&#x27;/user.json&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(p1) <span class="comment">// 异步1的回调结果</span></span><br><span class="line">        <span class="keyword">const</span> p2 = <span class="keyword">await</span> ajax(<span class="string">&#x27;/post.json&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(p2) <span class="comment">// 异步2的回调结果</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">syncAjax()</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise - MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX">Ajax - MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">Async - Function</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>异步编程</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript使用大全</title>
    <url>/2020/09/23/TypeScript%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p><code>TypeScript</code>是<code>JavaScript</code>的超集。</p>
</blockquote>
<p>我们知道<code>Javascript</code>是弱类型语言，而<code>Typescript</code>的出现就是为了解决js类型系统的不足，由于<strong>ts始于js，归于js</strong>的特点，从js过渡到ts是很容易的，且ts的类型系统提高了js代码的质量，我们有必要学习这门优秀的语言。</p>
<p>本文从js<strong>类型系统</strong>的问题出发，阐述ts构建的缘由和优势，<code>Folw</code>静态类型检测方案，以及<code>ts</code>基本的使用规则。</p>
<p><img data-src="/images/ts.png"></p>
<a id="more"></a>

<h2 id="强类型和弱类型"><a href="#强类型和弱类型" class="headerlink" title="强类型和弱类型"></a>强类型和弱类型</h2><blockquote>
<p><strong>强弱类型</strong>（Strong and weak typing）表示在<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>以及<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">程序设计</a>中，经常把<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">编程语言</a>的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">类型系统</a>分为<strong>强类型</strong>（英语：strongly typed）和<strong>弱类型</strong>（英语：weakly typed (loosely typed)）两种。这两个术语并<strong>没有非常明确的定义</strong>，但主要用以描述<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">编程语言</a>对于混入不同<a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5">资料类型</a>的值进行运算时的处理方式。强类型的语言遇到<strong>函数引数类型和实际调用类型不符合</strong>的情况经常会直接出错或者编译失败；而弱类型的语言常常会<strong>实行隐式转换</strong>，或者产生难以意料的结果。</p>
</blockquote>
<p>强类型语言和弱类型语言没有明确的定义划分，但有一个很明显的特点就是强类型语言在变量调用时和当前的变量类型一致，而弱类型语言可以传入不一致的类型，并在调用时会<strong>自动隐式转换</strong>。比如<code>js</code>的求和函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上，我们需要的参数<code>a</code>和<code>b</code>都应该是数字类型，否则就会发生难以预期的错误结果，在强类型语言比如<code>python</code>中，如果我们传入字符串，就会报类型错误，但是在弱类型语言<code>js</code>中可以正常执行。</p>
<p><code>javaScript</code>早期作为简单易用的脚本语言，是不需要编译环节而直接运行的，且代码量比较小，弱类型的特点成了<code>js</code>简单易用的优势。但随着js项目的复杂度越来越高，功能越来越多，弱类型语言带来的”不靠谱“特点就变成了<code>javascript</code>的劣势。也很容易在大型项目中出现常见的错误：</p>
<ul>
<li>类型不确定导致语法上的使用错误，需要在执行时才能发现。</li>
<li>有些错误执行时也不报错，会造成运行结果的不确定性，造成维护困难。</li>
<li>代码周期长，联系多，如果有重构需要，不敢轻易改动数据类型，需要大量测试，维护效率低。</li>
</ul>
<p>而弱类型劣势反之就是<strong>强类型的优势</strong>：</p>
<ul>
<li>错误更早暴露：执行前就能发现语法和调用上的错误</li>
<li>智能的代码提示：有了类型约束，智能提示就能更准确地提示，进而提高开发效率。</li>
<li>重构更牢靠：直接修改不恰当的数据类型就可以直接看到代码的错误提示，重构效率更高。</li>
<li>介绍不必要的类型判断：弱语言常常需要增加一些类型判断来控制不可靠的输出，而强类型就很少再需要这样的判断。</li>
</ul>
<h2 id="静态类型和动态类型"><a href="#静态类型和动态类型" class="headerlink" title="静态类型和动态类型"></a>静态类型和动态类型</h2><p>在类型检测层面，常常又把语言分为静态类型语言和动态类型语言，静态类型语言就是变量在申明时就需要指定变量的类型，且不可再变更类型，而动态类型则是可变更变量类型的语言。</p>
<p>比如在<code>js</code>中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;this is a message.&#x27;</span></span><br><span class="line">str = <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>这样直接把<code>string</code>类型变更为<code>number</code>类型是允许的，这就是动态类型语言，而在<code>java</code>中这样的赋值操作在编译时就会报错，这就是静态类型。</p>
<p>常见的语言类型划分如下：</p>
<p><img data-src="/images/image-20200922011455480.png"></p>
<h2 id="Flow类型检查器概述和使用"><a href="#Flow类型检查器概述和使用" class="headerlink" title="Flow类型检查器概述和使用"></a>Flow类型检查器概述和使用</h2><blockquote>
<p><code>Flow</code>是<code>javascript</code>的静态类型检查工具，能在编写js代码的同时进行<strong>类型推</strong>断和<strong>实时反馈</strong>。点击这里参考<a href="https://flow.org/">官方说明</a>。</p>
</blockquote>
<p><code>js</code>是脚本语言，没有编译环节，而且是弱类型语言，<code>Flow</code>工具就是为了完善<code>js</code>的类型系统而产生的类型检测工具，我们只需要在编写js代码时标注变量类型（即<strong>类型注解</strong>），就可以使用<code>flow</code>实时检测错误调用，让js也拥有<code>强类型</code>语言的特点。</p>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p>首先需要在项目环境安装<code>flow</code>包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add flow-bin --dev</span><br></pre></td></tr></table></figure>

<p>如果项目根目录没有<code>.flowconfig</code>文件，还需要初始化一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn flow init</span><br></pre></td></tr></table></figure>

<p>接下来，我们就可以使用类型注解的方式进行开发了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: number, b:number</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sum(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在变量名后使用<code>:类型</code>的方式就是类型注解。</p>
</blockquote>
<p>首先js是不支持类型注解的，所以上面的js代码还没运行可能编辑器就会提示错误，我们需要手动关掉编辑器的js检测，比如<code>vscode</code>可以在设置中搜索“javascript validate”，取消勾选即可。</p>
<p>在运行检测时，我们还需要手动在需要检测的文件开始行添加<code>@flow</code>的注释语句，然后开启检测：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn run flow</span><br></pre></td></tr></table></figure>

<p>然后就能在控制台看到对应的报错信息。</p>
<h3 id="移除注解"><a href="#移除注解" class="headerlink" title="移除注解"></a>移除注解</h3><p>现在的<code>js</code>代码是有类型注解的，因此直接运行会语法报错，需要使用<code>flow</code>提供的<code>flow-remove-types</code>模块进行移除，先安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add flow-remove-types --dev</span><br></pre></td></tr></table></figure>

<p>然后执行移除命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn flow-remove-types src -d dist</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将<code>src</code>目录下的文件编译到<code>dist</code>目录下。</p>
</blockquote>
<h3 id="配合babel使用"><a href="#配合babel使用" class="headerlink" title="配合babel使用"></a>配合babel使用</h3><p>很多时候我们都会安装别的编译工具，比如<code>babel</code>，这样，我们<code>babel</code>中的flow插件，首先我们安装<code>babel</code>工具和<code>flow</code>插件<code>preset-flow</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add @babel/core @babel/cli @babel/preset-flow --dev</span><br></pre></td></tr></table></figure>

<p>然后我们需要创建<code>babel</code>的配置文件<code>.babelrc</code>：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;@babel/preset-flow&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用命令就能编译出移除类型注解的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn babel src -d dist</span><br></pre></td></tr></table></figure>

<h3 id="使用编译器插件"><a href="#使用编译器插件" class="headerlink" title="使用编译器插件"></a>使用编译器插件</h3><p>使用<code>flow</code>模块需要我们每次都手动执行<code>yarn run flow</code>命令，且在控制台输出信息的方式并不直观，开发体验很差，所以我们更多的方式是使用编辑器配套的<code>flow</code>插件，<code>flow</code>在不同的编辑器都提供了自己的插件，比如<code>vscode</code>上，我们搜索<code>flow</code>：安装一个名叫：<code>Flow Language Support</code>的插件即可。</p>
<p>这样，我们不用手动执行检测命令，也能看到智能的错误标识：</p>
<p><img data-src="/images/image-20200922225644958.png"></p>
<h3 id="类型注解的使用"><a href="#类型注解的使用" class="headerlink" title="类型注解的使用"></a>类型注解的使用</h3><p>类型注解的使用和后面要讲到的<code>typescript</code>基本一致，感兴趣的可以参考官网的<a href="https://flow.org/en/docs/lang/">说明文档</a>。</p>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们一般把<code>typescript</code>称为<code>javascript</code>的超集，其实<code>es</code>相当于<code>js</code>的所有语法 + 类型系统 + <code>es6+</code>的新语法，而且<code>ts</code>最终也是编译为<code>js</code>来运行，使用<code>ts</code>来开发，你能体验到<code>js</code>没有的类型系统智能检测，以及体验<code>ecmascript</code>的一些新语法，基本是能实现完全平滑的过渡。</p>
<p><code>typescript</code>的学习成本是很低的，你甚至可以完完全全使用<code>js</code>的写法来编写<code>ts</code>，使用<code>ts</code>你可以当成你在使用<code>js</code> + <code>flow</code>进行开发，而<code>ts</code>其实会有更好的体验，没理由不接受<code>ts</code>。</p>
<h3 id="快速上手-1"><a href="#快速上手-1" class="headerlink" title="快速上手"></a>快速上手</h3><p>由于<code>ts</code>本身就是<code>js</code>语法的超集，我们只需要把我们的<code>.js</code>文件改为<code>.ts</code>文件就能正常运作：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">sum(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代其实就是上面配合<code>flow</code>时的语法，而我们现在不需要启动<code>flow</code>，<code>vscode</code>就能正确给出智能提示。</p>
<p>同样，如果需要正常运行，也是需要编译为<code>js</code>文件，我们安装<code>ts</code>提供的模块<code>typescript</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add typescript --dev</span><br></pre></td></tr></table></figure>

<p>这个模块提供了<code>tsc</code>的命令(typescript compiler缩写)，就可以把我们编写的<code>ts</code>文件编译为<code>js</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn tsc filename.ts</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果编译的ts文件有类型错误，编译会失败并在控制台打印出对应的错误。</p>
</blockquote>
<h3 id="编译器配置文件"><a href="#编译器配置文件" class="headerlink" title="编译器配置文件"></a>编译器配置文件</h3><p><code>tsc</code>除了编译单个文件，其实还支持使用配置文件来修改编译配置，我们使用命令初始化并创建这个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn tsc --init</span><br></pre></td></tr></table></figure>

<p>然后就会在目录下创建一个名为<code>tsconfig.json</code>的配置文件。我们就可以指定编译目录，输出目录以及编译的js版本等待，有了配置文件，运行<code>yarn tsc</code>即可安装配置文件进行编译。</p>
<p>更多配置说明可以参考<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html">配置文件- 官方文档</a>。</p>
<h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">string</span> = <span class="string">&#x27;jinx&#x27;</span>;</span><br><span class="line"><span class="comment">// a = null</span></span><br><span class="line"><span class="comment">// a = undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">number</span> = <span class="number">100</span>;</span><br><span class="line">b = <span class="literal">NaN</span></span><br><span class="line">b = <span class="literal">Infinity</span></span><br><span class="line"><span class="comment">// b = undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// c = null</span></span><br><span class="line"><span class="comment">// c = undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// d = null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s: symbol = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，如果配置文件开启了<code>strict</code>严格模式，以上注释的代码都是不能使用的。此外，如果<code>symbol</code>类型报错，可能是配置文件的<code>lib</code>标准库没有包含支持<code>symbol</code>的库，我们就可以添加leix<code>es2015</code>这样的库。</p>
</blockquote>
<h3 id="显示中文的错误提示"><a href="#显示中文的错误提示" class="headerlink" title="显示中文的错误提示"></a>显示中文的错误提示</h3><p>如果希望类型提示时显示为中文，可以运行下面的命令进行语言切换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn tsc --local zh-CN</span><br></pre></td></tr></table></figure>

<p>或者有的编辑器也支持语言的修改，比如<code>vscode</code>中可以搜索”typescript locale”来切换语言。</p>
<p>但其实不建议这样做，当我们遇到不能理解的错误时可以更好地使用搜索引擎准确地找到错误描述。</p>
<h3 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h3><p>当我们在两个文件中声明了同名的变量，就会提示我们变量”XXX”重复声明的问题：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Cannot redeclare block-scoped variable &#x27;XXX&#x27;.</span><br></pre></td></tr></table></figure>

<p>这是因为，这两个文件目前下的变量都是全局作用域的，而我们一般会把一个<code>ts</code>文件当做一个模块来使用，所以我们只需要在文件中使用<code>export</code>关键字进行<strong>标识</strong>即可：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">string</span> = <span class="string">&#x27;jinx&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，一个ts文件可以使用多个<code>export</code>关键字，也可以使用<code>export default</code>来导出一个对象。</p>
</blockquote>
<h3 id="object类型"><a href="#object类型" class="headerlink" title="object类型"></a>object类型</h3><blockquote>
<p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">declare <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | null</span>): <span class="title">void</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: <span class="number">0</span> &#125;</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">null</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span>); // <span class="title">OK</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="number">42</span></span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="string">&quot;string&quot;</span></span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">false</span>); // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">undefined</span>); // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure>

<p>但是我们<strong>一般不使用</strong>这个类型，我们常常使用更准确的<code>接口</code>来描述对象类型。</p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>数组的类型定义，我们一般有两种方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一：使用[]标识</span></span><br><span class="line"><span class="keyword">const</span> arr1: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：使用Array泛型</span></span><br><span class="line"><span class="keyword">const</span> arr2: <span class="built_in">Array</span>&lt;string&gt; = [<span class="string">&#x27;jinx&#x27;</span>, <span class="string">&#x27;yasuo&#x27;</span>, <span class="string">&#x27;jax&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="元祖类型"><a href="#元祖类型" class="headerlink" title="元祖类型"></a>元祖类型</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tuple: [string, number] = [<span class="string">&#x27;jinx&#x27;</span>, <span class="number">23</span>]</span><br><span class="line"><span class="keyword">const</span> [_name, _age] = tuple;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p><code>enum</code>类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。一般我们用于定义一些通用的常量，比如红绿灯：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> LightColor &#123;</span><br><span class="line">    RED,</span><br><span class="line">    YELLOW,</span><br><span class="line">    BLUE,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 <code>1</code>开始编号：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> LightColor &#123;</span><br><span class="line">    RED = <span class="number">1</span>,</span><br><span class="line">    YELLOW,</span><br><span class="line">    BLUE,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果使用字符串进行编号，你需要为每个成员进行编号。</p>
</blockquote>
<p>实际上，枚举是会被编译为一种双向绑定的对象，比如上面的枚举对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> LightColor;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">LightColor</span>) </span>&#123;</span><br><span class="line">    LightColor[LightColor[<span class="string">&quot;RED&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;RED&quot;</span>;</span><br><span class="line">    LightColor[LightColor[<span class="string">&quot;YELLOW&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;YELLOW&quot;</span>;</span><br><span class="line">    LightColor[LightColor[<span class="string">&quot;BLUE&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;BLUE&quot;</span>;</span><br><span class="line">&#125;)(LightColor || (LightColor = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>所以我们可以通过编号反向获得枚举的名称：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;Red = <span class="number">1</span>, Green, Blue&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>]; <span class="comment">// Green</span></span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>和JavaScript一样，TypeScript函数可以创建有名字的函数和匿名函数，函数一般是输入和输出的工具，所以类型声明时也是对输入类型和输出类型最类型注解。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h4><p>TypeScript里的每个函数参数都是必须的。 这不是指不能传递 <code>null</code>或<code>undefined</code>作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</p>
<p>JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用 <code>?</code>实现可选参数的功能。 比如，我们想让last name是可选的：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">&quot;Bob&quot;</span>);  <span class="comment">// works correctly now</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>, <span class="string">&quot;Sr.&quot;</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Adams&quot;</span>);  <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可选参数必须跟在必须参数后面。</p>
</blockquote>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 <code>arguments</code>来访问所有传入的参数。</p>
<p>在TypeScript里，你可以把所有参数收集到一个变量里：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + restOfName.join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">&quot;Joseph&quot;</span>, <span class="string">&quot;Samuel&quot;</span>, <span class="string">&quot;Lucas&quot;</span>, <span class="string">&quot;MacKinzie&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，<code>ES6</code>已经支持这种语法。</p>
</blockquote>
<h3 id="任意类型"><a href="#任意类型" class="headerlink" title="任意类型"></a>任意类型</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>any</code>其实就是跳过了类型检查。</p>
</blockquote>
<h3 id="隐式类型推断"><a href="#隐式类型推断" class="headerlink" title="隐式类型推断"></a>隐式类型推断</h3><p>当我们在声明变量时直接赋值而为做类型声明，ts能自动推断出赋值类型作为当前变量的类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">9</span> <span class="comment">// 自动推断为number类型</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实并不推荐隐式类型推断，我们应该尽可能手动注解类型。</p>
</blockquote>
<h3 id="类型注解-1"><a href="#类型注解-1" class="headerlink" title="类型注解"></a>类型注解</h3><p>有时候，某个变量可能有多个类型，或者为<code>any</code>类型，但我们明确知道数据来源，就可以使用类型断言，强制声明为某种类型，比如下面的示例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = nums.find(<span class="function"><span class="params">i</span> =&gt;</span> i &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = res ** <span class="number">2</span>; <span class="comment">// Object is possibly &#x27;undefined&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>在严格模式下，<code>res</code>会被推断为<code>number | undefined</code>类型，但是我们十分明确的知道，nums不可能返回<code>undefined</code>。</p>
<p>这时为了避免报错，我们可以使用<code>as</code>关键字进行类型断言：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> square = (res <span class="keyword">as</span> <span class="built_in">number</span>) ** <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> square = (&lt;<span class="built_in">number</span>&gt;res) ** <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&lt;type&gt;</code>也可以作为类型断言的标识，但不推荐使用，因为可能会与项目中使用的<code>JSX</code>等工具冲突。</p>
</blockquote>
<p>值得注意的是，类型断言并不会改变变量的类型，只是在使用时进行强制性地类型标注，以此避开类型检测检测错误。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote>
<p>TypeScript的核心原则之一是对值所具有的<em>结构</em>进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
</blockquote>
<p>比如，我们定义了一个自我介绍的方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfIntroduction</span>(<span class="params">p: any</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, my name is <span class="subst">$&#123;p.name&#125;</span>, I am <span class="subst">$&#123;p.age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，我们希望获得的对象<code>p</code>必须包含<code>name</code>和<code>age</code>属性，这就是一种约定，或者是这个函数的规范，我们就可以使用接口来进行类型声明。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfIntroduction</span>(<span class="params">p: Person</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hello, my name is <span class="subst">$&#123;p.name&#125;</span>, I am <span class="subst">$&#123;p.age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口成员我们还可以设置为可选和只读，就像这样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="keyword">readonly</span> idnumber: <span class="built_in">string</span>; <span class="comment">// 只读参数</span></span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">    hobbies?: <span class="built_in">string</span>[]; <span class="comment">// 可选参数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>如果你已经使用了<code>ES6</code>的类Class，在<code>ts</code>中的类也是大同小异的。</p>
<p>这里就不在多做赘述，可参考<a href="https://www.tslang.cn/docs/handbook/classes.html">官方文档</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://www.tslang.cn/docs/release-notes/typescript-3.1.html">docs - typescript</a></li>
</ol>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>自动化构建</title>
    <url>/2020/11/10/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>一切重复性的工作都应该被自动化。</p>
</blockquote>
<p>在前端工程化中，我们常常希望使用更有的模块进行项目开发，比如我们可能使用模板引擎进行页面渲染，使用<code>sass</code>来构建<code>css</code>，使用最新的<code>ECMAScript</code>语法或者<code>ts</code>进行业务逻辑开发。而以上的模块或者技能都只是一项选择，最终我们都需要转化为最基本的前端三件套：<code>html</code> + <code>css</code> + <code>js</code>。这其中的转换过程根据不同工具的使用而不同，但无疑都是重复性的工作，类似这些开发过程中的重复的工作，都应该使用自动化的思想为我们解决，我们只需要关注代码的业务逻辑和最终的准换结果，而中间的处理过程，都应该交给自动化构建工具。</p>
<p>除了基本的格式转换，自动化构建工具一般还具有压缩、合并、文件整理、启动服务、格式化代码等功能。</p>
<p><img data-src="/images/gulp.jpg"></p>
<p>本文将会从三款前端自动构建工具<a href="https://www.gruntjs.net/">grunt</a>、<a href="https://www.gulpjs.com.cn/">gulp</a>、<a href="http://fis.baidu.com/">fis</a>的使用中感受自动化构建的特点和优势。</p>
<a id="more"></a>

<h2 id="Grunt的使用"><a href="#Grunt的使用" class="headerlink" title="Grunt的使用"></a>Grunt的使用</h2><p><a href="https://www.gruntjs.net/">grunt</a>是比较早的一款前端自动构建工具，插件也比较丰富，目前的使用人数仍然很多，但已被后起之秀<a href="https://www.gulpjs.com.cn/">gulp</a>赶超，相比之下，<code>gulp</code>在使用上更简洁和高效，不过这些都因人而异，<code>grunt</code>同样是一款优秀的构建工具，我们有必要一探究竟。</p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>首先我们初始化一个目录，并新建<code>package.json</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir guruntDemo</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>安装<code>grunt</code>模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i grunt --dev</span><br></pre></td></tr></table></figure>

<p><code>grunt</code>工具可以看作是<strong>任务流的操作逻辑</strong>，比如html模板解析、sass转为css等自动任务都看作是一项一项的任务，我们在<code>grunt</code>中注册这些任务，并支持自由组合，然后使用<code>npm run</code>就能启动这些自动任务。</p>
<p>为了正常启动<code>grunt</code>任务，默认的入口配置文件为：<code>gruntfile.js</code>或<code>gruntfile.coffe</code>。（可以使用大写<code>Gruntfile.js</code>）。</p>
<p><code>gruntfile</code>文件需要默认导出一个参数为<code>grunt</code>的函数，我们使用<code>grunt.registerTask</code>方法就可以进行任务的注册：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">grunt</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 参数说明：(任务名, [描述信息,] 任务列表|任务函数) </span></span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;解析html模板&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;渲染html...&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行任务：（如果没有全局安装<code>grunt-cli</code>，我们需要手动修改<code>package.json</code>文件的<code>scripts</code>字段，让其支持<code>npm run</code>命令）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run grunt html</span><br></pre></td></tr></table></figure>

<p>这样我们就能看到注册的<code>html</code>任务的执行结果。</p>
<p>使用<code>default</code>作为默认任务参数时，可以直接使用<code>npm run grunt</code>进行默认任务执行。</p>
<p><code>registerTask</code>函数除了指定函数，一般我们都直接指定任务名即可，这个任务名就是我们已经注册的任务，或者是使用插件注册好的任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">grunt</span>) =&gt;</span> &#123;</span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;html&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;渲染html...&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;sass&#x27;</span>, <span class="function">() =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;sass文件转化...&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;sass&#x27;</span>]); <span class="comment">// 任务组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你创建了一个<strong>异步任务</strong>，那么你需要使用<code>this.async()</code>作为异步结束标识，否则任务将不会执行异步代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步任务的注册</span></span><br><span class="line">grunt.registerTask(<span class="string">&#x27;asyncTask&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> done = <span class="built_in">this</span>.async(); <span class="comment">// 强制任务进入异步模式，并获取“done”函数的句柄。</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;This is a Async Task.&#x27;</span>);</span><br><span class="line">        done(); <span class="comment">// 异步任务结束标记</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="任务失败标记"><a href="#任务失败标记" class="headerlink" title="任务失败标记"></a>任务失败标记</h3><p>如果任务内部某些代码已经（或即将）崩溃，可能导致Grunt强行中止。我们可以<strong>手动标记该任务为失败任务</strong>，在任务队列中，这会终止后续任务队列的执行，如果遇到错误任务时需要强制执行需要加上<code>--force</code>命令。</p>
<p>标记失败任务的方法很简单，我们只需要让任务函数返回<code>false</code>即可，或者使用失败标记<code>api</code>：<code>grunt.fail.warn</code>或者<code>grunt.fail.fatal</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">grunt</span>) =&gt;</span> &#123;</span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;badTask&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;doing....&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 返回false，标记任务失败</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;badTask2&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;doing....&#x27;</span>)</span><br><span class="line">       grunt.fail.warn(<span class="string">&#x27;something wrong!&#x27;</span>) <span class="comment">// 标记任务失败</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;keep going use --force&#x27;</span>) <span class="comment">// 标记失败后，使用--force才能继续执行后续任务 </span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;badTask3&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;doing....&#x27;</span>)</span><br><span class="line">       grunt.fail.fatal(<span class="string">&#x27;something wrong!&#x27;</span>) <span class="comment">// 标记任务失败</span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;can not keep going use --force&#x27;</span>) <span class="comment">// 使用fatal标记失败后，即使使用--force也无法继续执行后续任务 </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：使用<code>grunt.warn</code>和<code>grunt.fatal</code>是一样的效果。</p>
<p>如果是异步函数，也是一样的用法，如果不使用官方api，在<code>done</code>的参数中传入<code>false</code>即可。</p>
</blockquote>
<h3 id="Grunt的配置config"><a href="#Grunt的配置config" class="headerlink" title="Grunt的配置config"></a>Grunt的配置config</h3><p><code>grunt.config</code>可以从 <code>Gruntfile</code> 中获取针对当前项目的<strong>配置数据</strong>。</p>
<h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><p>使用<code>grunt.config.init</code>或<code>grunt.initConfig</code>进行配置初始化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">grunt</span>) =&gt;</span> &#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        html: &#123;</span><br><span class="line">            src: <span class="string">&#x27;src/html/*.html&#x27;</span>,</span><br><span class="line">            out: <span class="string">&#x27;dist/html&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;html&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;渲染路径：&#x27;</span>, grunt.config(<span class="string">&#x27;html.src&#x27;</span>))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;输出路径：&#x27;</span>, grunt.config(<span class="string">&#x27;html.out&#x27;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置的获取和设置"><a href="#配置的获取和设置" class="headerlink" title="配置的获取和设置"></a>配置的获取和设置</h4><p>使用<code>grunt,config.get(prop)</code>可以获取配置的数据。</p>
<p>使用<code>grunt,config.set(prop, value)</code>可以获取配置的数据。</p>
<p>当然，你可以使用<code>grunt.config(prop [, value])</code>可以进行设置或者获取操作。</p>
<p>值得注意的是，<code>prop</code>参数可以传入<code>html.src</code>这种以<code>.</code>分割的字符串，这样，需要数据的时候将会逐级查找。</p>
<p>更多配置相关的<code>api</code>可参考<a href="https://www.gruntjs.net/api/grunt.config#grunt.config">官方说明</a>。</p>
<h3 id="多目标任务（复合任务）"><a href="#多目标任务（复合任务）" class="headerlink" title="多目标任务（复合任务）"></a>多目标任务（复合任务）</h3><p>这里的多目标任务和上面说到的任务队列有所区别。<strong>复合任务</strong>是指在不指定目标（target）时，将依次执行其所包含的所有已命名的子属性（sub-properties） (也就是 目标) 。大多数的contrib任务，包括 <a href="https://github.com/gruntjs/grunt-contrib-jshint">jshint task</a>、<a href="https://github.com/gruntjs/grunt-contrib-concat">concat task</a> 和 <a href="https://github.com/gruntjs/grunt-contrib-uglify">uglify task</a> 都是复合任务。</p>
<p>多目标任务需要配合配置<code>grunt.config</code>来使用，就比如我们上面定义的<code>html</code>任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">grunt</span>) =&gt;</span> &#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        html: &#123;</span><br><span class="line">            src: <span class="string">&#x27;src/html/*.html&#x27;</span>,</span><br><span class="line">            out: <span class="string">&#x27;dist/html&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    grunt.registerMultiTask(<span class="string">&#x27;html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        grunt.log.writeln(<span class="built_in">this</span>.target + <span class="string">&#x27;: &#x27;</span> + <span class="built_in">this</span>.data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>yarn grunt html</code>就可以看到下面的效果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grunt html</span></span><br><span class="line">Running &quot;html:src&quot; (html) task</span><br><span class="line">src: src/html/*.html</span><br><span class="line"></span><br><span class="line">Running &quot;html:out&quot; (html) task</span><br><span class="line">out: dist/html</span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line">Done in 0.42s.</span><br></pre></td></tr></table></figure>

<p>配置项<code>html</code>中的<code>src</code>和<code>out</code>就是多目标任务<code>html</code>的目标项，将会逐一执行注册的多目标任务函数。</p>
<blockquote>
<p>使用<code>this.target</code>可以获取到当前目前的键，使用<code>this.data</code>可以获取到当前目标对象配置项的值。</p>
</blockquote>
<p>值得注意的一点是，<code>options</code>是一个特别的配置键，一般用于存储一些通用选项，而不会当做目标指向，我们可以使用<code>this.options</code>拿到这些数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">grunt</span>) =&gt;</span> &#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        html: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                foo: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">                bar: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            src: &#123;</span><br><span class="line">                options: &#123;</span><br><span class="line">                    foo: <span class="string">&#x27;src_foo&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                file: <span class="string">&#x27;src/html/*.html&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            out: <span class="string">&#x27;dist/html&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    grunt.registerMultiTask(<span class="string">&#x27;html&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.options())</span><br><span class="line">        grunt.log.writeln(<span class="built_in">this</span>.target + <span class="string">&#x27;: &#x27;</span> + <span class="built_in">this</span>.data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grunt html</span></span><br><span class="line">Running &quot;html:src&quot; (html) task</span><br><span class="line">&#123; foo: &#x27;src_foo&#x27;, bar: &#x27;bar&#x27; &#125;</span><br><span class="line">src: [object Object]</span><br><span class="line"></span><br><span class="line">Running &quot;html:out&quot; (html) task</span><br><span class="line">&#123; foo: &#x27;foo&#x27;, bar: &#x27;bar&#x27; &#125;    </span><br><span class="line">out: dist/html</span><br><span class="line"></span><br><span class="line">Done.</span><br><span class="line">Done in 0.44s.</span><br></pre></td></tr></table></figure>

<h3 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h3><p>大多数使用我们都是使用插件执行自动化任务工作的，而很少手动使用<code>registerTask</code>注册任务。</p>
<p>在<code>grunt</code>中使用插件，一般有三个步骤：</p>
<ul>
<li>首先是<strong>安装</strong>这个插件模块到本地</li>
<li>在配置数据中更具插件说明<strong>配置</strong>相关配置项</li>
<li>使用<code>loadNpmTasks</code>注册插件提供的任务。</li>
</ul>
<p>比如我们使用一款文件清理插件：<a href="https://www.npmjs.com/package/grunt-contrib-clean">grunt-contrib-clean</a>：</p>
<p>首先，安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i grunt-contrib-clean --dev</span><br></pre></td></tr></table></figure>

<p>然后，配置相关插件配置项，并注册插件任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">grunt</span>) =&gt;</span> &#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        clean: [<span class="string">&#x27;temp/**&#x27;</span>, <span class="string">&#x27;dist/html/**&#x27;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    grunt.loadNpmTasks(<span class="string">&#x27;grunt-contrib-clean&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击这里访问插件官方提供的<a href="https://www.gruntjs.net/plugins">插件列表</a>。</p>
<h3 id="常用的一些插件"><a href="#常用的一些插件" class="headerlink" title="常用的一些插件"></a>常用的一些插件</h3><h4 id="load-grunt-tasks"><a href="#load-grunt-tasks" class="headerlink" title="load-grunt-tasks"></a><a href="https://www.npmjs.com/package/load-grunt-tasks">load-grunt-tasks</a></h4><p>当使用的插件增多时，我们需要多次使用<code>grunt.loadNpmTasks</code>来注册插件任务，我们可以借助这个插件来<strong>自动注册配置项里的插件</strong>。</p>
<p>安装完成后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadGruntTasks =  <span class="built_in">require</span>(<span class="string">&#x27;load-grunt-tasks&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        clean: &#123;</span><br><span class="line">            temp: <span class="string">&#x27;temp/&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    loadGruntTasks(grunt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grunt-sass"><a href="#grunt-sass" class="headerlink" title="grunt-sass"></a><a href="https://www.npmjs.com/package/grunt-sass">grunt-sass</a></h4><p><code>grunt-sass</code>需要<code>node-sass</code>的支持，所以安装时需要多安装一个模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save-dev node-sass grunt-sass</span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadGruntTasks =  <span class="built_in">require</span>(<span class="string">&#x27;load-grunt-tasks&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&#x27;sass&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        sass: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                implementation: sass,</span><br><span class="line">                sourceMap: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            dist: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    <span class="string">&#x27;dist/css/main.css&#x27;</span>: <span class="string">&#x27;src/sass/main.scss&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;dist/css/footer.css&#x27;</span>: <span class="string">&#x27;src/sass/footer.scss&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    loadGruntTasks(grunt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grunt-babel"><a href="#grunt-babel" class="headerlink" title="grunt-babel"></a><a href="https://www.npmjs.com/package/grunt-babel">grunt-babel</a></h4><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn add --dev grunt-babel @babel/core @babel/preset-env</span></span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadGruntTasks =  <span class="built_in">require</span>(<span class="string">&#x27;load-grunt-tasks&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        babel: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">              sourceMap: <span class="literal">true</span>,</span><br><span class="line">              presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            dist: &#123;</span><br><span class="line">              files: &#123;</span><br><span class="line">                <span class="string">&#x27;dist/js/main.js&#x27;</span>: <span class="string">&#x27;src/js/main.js&#x27;</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    loadGruntTasks(grunt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grunt-contrib-watch"><a href="#grunt-contrib-watch" class="headerlink" title="grunt-contrib-watch"></a><a href="https://www.npmjs.com/package/grunt-contrib-watch">grunt-contrib-watch</a></h4><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install grunt-contrib-watch --save-dev</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadGruntTasks =  <span class="built_in">require</span>(<span class="string">&#x27;load-grunt-tasks&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&#x27;sass&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        clean: [<span class="string">&#x27;dist&#x27;</span>],</span><br><span class="line">        sass: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                implementation: sass,</span><br><span class="line">                sourceMap: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            dist: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    <span class="string">&#x27;dist/css/main.css&#x27;</span>: <span class="string">&#x27;src/sass/main.scss&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;dist/css/footer.css&#x27;</span>: <span class="string">&#x27;src/sass/footer.scss&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        babel: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                sourceMap: <span class="literal">true</span>,</span><br><span class="line">                presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            dist: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    <span class="string">&#x27;dist/js/main.js&#x27;</span>: <span class="string">&#x27;src/js/main.js&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            css: &#123;</span><br><span class="line">                files: [<span class="string">&#x27;src/sass/**.scss&#x27;</span>],</span><br><span class="line">                tasks: [<span class="string">&#x27;clean&#x27;</span>, <span class="string">&#x27;sass&#x27;</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            scripts: &#123;</span><br><span class="line">                files: [<span class="string">&#x27;src/js/**.js&#x27;</span>],</span><br><span class="line">                tasks: [<span class="string">&#x27;clean&#x27;</span>, <span class="string">&#x27;babel&#x27;</span>],</span><br><span class="line">                options: &#123;</span><br><span class="line">                    spawn: <span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    loadGruntTasks(grunt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grunt-contrib-connect"><a href="#grunt-contrib-connect" class="headerlink" title="grunt-contrib-connect"></a><a href="https://www.npmjs.com/package/grunt-contrib-connect">grunt-contrib-connect</a></h4><p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install grunt-contrib-connect --save-dev</span><br></pre></td></tr></table></figure>

<p>结合<code>watch</code>的使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loadGruntTasks =  <span class="built_in">require</span>(<span class="string">&#x27;load-grunt-tasks&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> sass = <span class="built_in">require</span>(<span class="string">&#x27;sass&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        clean: &#123;</span><br><span class="line">            css: <span class="string">&#x27;dist/css&#x27;</span>,</span><br><span class="line">            js: <span class="string">&#x27;dist/js&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        sass: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                implementation: sass,</span><br><span class="line">                sourceMap: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            dist: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    <span class="string">&#x27;dist/css/main.css&#x27;</span>: <span class="string">&#x27;src/sass/main.scss&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;dist/css/footer.css&#x27;</span>: <span class="string">&#x27;src/sass/footer.scss&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        babel: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                sourceMap: <span class="literal">true</span>,</span><br><span class="line">                presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            dist: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    <span class="string">&#x27;dist/js/main.js&#x27;</span>: <span class="string">&#x27;src/js/main.js&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                livereload: <span class="literal">true</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            css: &#123;</span><br><span class="line">                files: [<span class="string">&#x27;src/sass/**.scss&#x27;</span>],</span><br><span class="line">                tasks: [<span class="string">&#x27;clean:css&#x27;</span>, <span class="string">&#x27;sass&#x27;</span>],</span><br><span class="line">            &#125;,</span><br><span class="line">            scripts: &#123;</span><br><span class="line">                files: [<span class="string">&#x27;src/js/**.js&#x27;</span>],</span><br><span class="line">                tasks: [<span class="string">&#x27;clean:js&#x27;</span>, <span class="string">&#x27;babel&#x27;</span>],</span><br><span class="line">                options: &#123;</span><br><span class="line">                    spawn: <span class="literal">false</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        connect: &#123;</span><br><span class="line">            server: &#123;</span><br><span class="line">                options: &#123;</span><br><span class="line">                    port: <span class="number">8000</span>,</span><br><span class="line">                    <span class="comment">// keepalive: true,</span></span><br><span class="line">                    open: <span class="literal">true</span>,</span><br><span class="line">                    base: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">                    index: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">                    livereload: <span class="literal">true</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    loadGruntTasks(grunt);</span><br><span class="line">    grunt.registerTask(<span class="string">&#x27;default&#x27;</span>, [<span class="string">&#x27;connect&#x27;</span>, <span class="string">&#x27;watch&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gulp的使用"><a href="#Gulp的使用" class="headerlink" title="Gulp的使用"></a>Gulp的使用</h2><blockquote>
<p><a href="https://www.gulpjs.com.cn/">gulp</a> 将开发流程中让人痛苦或耗时的任务自动化，从而减少你所浪费的时间、创造更大价值。</p>
</blockquote>
<p>使用之下发现，<code>gulp</code>相较于<code>grunt</code>来说更灵活易用，grunt是通过注册一个一个的任务来完成自动化操作的，而gulp则是<strong>基于流（stream）操作</strong>来实现的。</p>
<h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>首先安装的<code>gulp</code>模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install gulp --dev</span><br></pre></td></tr></table></figure>

<p>创建gulp的入口文件：<code>gulpfile.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a task...&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    aTask</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与<code>grunt</code>不同的是，我们只需要导出模块函数，这个函数就会被注册为一个任务，我们试着执行一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn gulp aTask</span><br></pre></td></tr></table></figure>

<p>可以看到打印结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn run v1.22.5</span><br><span class="line"><span class="meta">$</span><span class="bash"> gulp aTask</span></span><br><span class="line">[08:26:21] Using gulpfile D:\Test\gulpDemo\gulpfile.js</span><br><span class="line">[08:26:21] Starting &#x27;aTask&#x27;...</span><br><span class="line">this is a task...</span><br><span class="line">[08:26:21] The following tasks did not complete: aTask</span><br><span class="line">[08:26:21] Did you forget to signal async completion? </span><br><span class="line">error Command failed with exit code 1.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.</span><br></pre></td></tr></table></figure>

<p>我们发现，任务正常执行了，但是有报错提示<code>Did you forget to signal async completion? </code>。这是因为，gulp中的任务都必须是异步的，因此，我们需要返回异步结束标记来标记任务正常结束，我们可以使用任务函数的参数<code>done</code>来处理，也可以直接返回<code>Promise.resolve</code>来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aTask</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a task...&#x27;</span>)</span><br><span class="line">    done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aTask2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a task...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    aTask,</span><br><span class="line">    sTask2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能正常执行了。</p>
<blockquote>
<p>早期版本注册一个任务有点类似<code>grunt</code>，我们可以使用<code>require(&#39;gulp&#39;).task(taskName, taskFun)</code>来实现，但目前我们只需要直接当做普通函数导出模块即可自动完成注册。</p>
</blockquote>
<h3 id="组合任务和异步任务"><a href="#组合任务和异步任务" class="headerlink" title="组合任务和异步任务"></a>组合任务和异步任务</h3><p>在<code>grunt</code>中通过<code>grunt.registerTask</code>或<code>grunt.registerMultiTask </code>的api，使用<strong>任务列表的模式</strong>进行任务组合，但有一个问题就是异步函数会阻断往往会暂停任务列表的执行，而在<code>gulp</code>中就显得更加灵活。</p>
<p>在<code>gulp</code>中，有两种任务组合的方式：队列（同步）执行任务（series）和异步执行任务（parallel）。</p>
<p>队列执行就是，安装排列的任务顺序依次执行，上一个执行结束后再执行下一个任务。而异步执行任务就是，多个任务异步执行，不会相互阻塞。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;series, parallel&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;task1 runing...&#x27;</span>)</span><br><span class="line">    done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task2</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;task2 runing...&#x27;</span>)</span><br><span class="line">    done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">task1_async</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;task1_async runing...&#x27;</span>)</span><br><span class="line">        done()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> task_list = series(task1, task1_async, task2) <span class="comment">// 同步执行队列：就算存在异步模式也并不会阻断后续任务的执行</span></span><br><span class="line"><span class="keyword">const</span> async_task_list = parallel(task1, task1_async, task2) <span class="comment">// 异步执行队列，任务同时执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    task_list,</span><br><span class="line">    async_task_list</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，gulp中的任务都被定义为异步任务，如过想要任务执行失败错误，可以使用：<code>done(new Error())</code>或者<code>return Promise.reject()</code>的形式。</p>
<p>需要注意的是，一旦某个任务执行失败，不管是用<code>series</code>还是<code>parallel</code>来组合任务，都会导致任务队列终止运行。</p>
<h3 id="核心工作原理：文件流模式（The-Streaming-Building-System）"><a href="#核心工作原理：文件流模式（The-Streaming-Building-System）" class="headerlink" title="核心工作原理：文件流模式（The Streaming Building System）"></a>核心工作原理：文件流模式（The Streaming Building System）</h3><p>正如<code>grunt</code>的使用过程一样，不管是我们需要编译模板文件，编译sass文件，还是别的什么文件，<strong>都是在对文件做处理</strong>，比如<code>*.scss</code>输出为<code>*.css</code>文件。</p>
<p><code>gulp</code>的核心工作原理也是这个逻辑：文件流构建模式：**<code>输入流 → 转换流（加工）→ 输出流 </code>**。</p>
<p>输入流就是读取文件内容，输出流就是写入文件，这些操作都可以使用<code>fs</code>模块实现，而转换流就是内容加工的过程，我们可以借助一个第三方模块：<code>stream</code>中的<code>Transform</code>类来实现。</p>
<p>下面我们使用文件流模式来实现压缩<code>css</code>的过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123;Transform&#125; = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> minCss = <span class="function">(<span class="params">done</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 输入流：读取文件</span></span><br><span class="line">    <span class="keyword">const</span> read = fs.createReadStream(<span class="string">&#x27;main.css&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换流：文件加工、转换的过程</span></span><br><span class="line">    <span class="keyword">const</span> transform = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">        transform: <span class="function"><span class="keyword">function</span>(<span class="params">chunk, encoding, callback</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 转换流的核心处理逻辑</span></span><br><span class="line">            <span class="keyword">const</span> input = chunk.toString();</span><br><span class="line">            <span class="comment">// css的压缩逻辑</span></span><br><span class="line">            <span class="keyword">const</span> output = input</span><br><span class="line">                .replace(<span class="regexp">/\s+\&#123;/g</span>, <span class="string">&#x27;&#123;&#x27;</span>) <span class="comment">// &#123;前后的空白字符</span></span><br><span class="line">                .replace(<span class="regexp">/\&#123;\s+/g</span>, <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                .replace(<span class="regexp">/\s+\&#125;/g</span>, <span class="string">&#x27;&#125;&#x27;</span>) <span class="comment">// &#125;前后的空白字符</span></span><br><span class="line">                .replace(<span class="regexp">/\&#125;\s+/g</span>, <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                .replace(<span class="regexp">/;\&#125;/g</span>, <span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line">                .replace(<span class="regexp">/\s+:/g</span>, <span class="string">&#x27;:&#x27;</span>) <span class="comment">// :前后的空白字符</span></span><br><span class="line">                .replace(<span class="regexp">/:\s+/g</span>, <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">                .replace(<span class="regexp">/\/\*.+?\*\//g</span>, <span class="string">&#x27;&#x27;</span>); <span class="comment">// 注释</span></span><br><span class="line">            callback(<span class="literal">null</span>, output);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出流：写入文件</span></span><br><span class="line">    <span class="keyword">const</span> write = fs.createWriteStream(<span class="string">&#x27;main.min.css&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用管道pipe来控制文件流</span></span><br><span class="line">    read</span><br><span class="line">        .pipe(transform)</span><br><span class="line">        .pipe(write)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 异步执行结束标记</span></span><br><span class="line">    <span class="comment">// read.on(&#x27;end&#x27;, done);</span></span><br><span class="line">    <span class="keyword">return</span> read;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    minCss,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这也是<code>gulp</code>最核心的文件操作过程。</p>
</blockquote>
<p><code>gulp</code>中提供了文件流操作的api，这样我们就不需要通过<code>fs</code>模块来实现了，而<code>gulp</code>中提供的插件相当于转换流插件，这样，我们就能通过流模式就像简洁高效地开发啦。</p>
<p><code>gulp</code>提供的读取流使用<code>src</code>对象，写入流使用<code>dest</code>对象，而转换流则是相应的插件来实现。</p>
<p>比如上面我们实现css文件压缩任务，用gulp中的api和插件来实现则是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cleanCss = <span class="built_in">require</span>(<span class="string">&#x27;gulp-clean-css&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> minCss = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;*.css&#x27;</span>) <span class="comment">// 读取css文件，可使用通配符</span></span><br><span class="line">        .pipe(cleanCss()) <span class="comment">// 转换流</span></span><br><span class="line">        .pipe(dest(<span class="string">&#x27;mincss&#x27;</span>)) <span class="comment">// 写入流，参数为目录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    minCss</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后的案例基本都是这个不变的模式，区别在于插件的选择而已，所以使用起来十分方便。</p>
<blockquote>
<p>使用<code>grunt</code>的感觉就是在找插件，写配置文件，其实使用<code>gulp</code>的感觉也是如此，找到适合的插件，写配置，传入<code>pipe</code>管道中作为转换流调用，虽然在使用上都是在找插件的过程，但<code>gulp</code>采用的这种流模式更清晰，更高效，也更灵活，我们可以在管道流中自由使用自己想要加工的效果插件。</p>
</blockquote>
<h3 id="样式编译"><a href="#样式编译" class="headerlink" title="样式编译"></a>样式编译</h3><p>这里以<code>sass</code>文件为例，编译为<code>css</code>文件，我们需要使用<a href="https://www.npmjs.com/package/gulp-sass">gulp-sass</a>这个插件。</p>
<p>在开始之前，我们需要准备好一些测试文件，比如在项目下创建这些样式文件：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">└───src</span><br><span class="line">    ├───assets</span><br><span class="line">        ├───styles</span><br><span class="line">            └───_icons.scss</span><br><span class="line">            └───_variables.scss</span><br><span class="line">            └───main.scss</span><br></pre></td></tr></table></figure>

<p>下面是最基本的使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;src, dest&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> transform_sass = <span class="built_in">require</span>(<span class="string">&#x27;gulp-sass&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> style = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>)</span><br><span class="line">        .pipe(transform_sass())</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    style</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行编译命令后，我们发现，在<code>dist</code>目录下多了一个文件：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">└───dist</span><br><span class="line">    └───main.css</span><br></pre></td></tr></table></figure>

<p>我们发现，<code>_icons.scss</code>和<code>_variables.scss</code>未编译，这是因为一般来说，我们都把<code>_</code>开头的样式文件作为其他样式文件的依赖，而不会单独存在，所以没必要编译出来，<code>sass</code>会自动过滤这些文件。</p>
<p>有时候我们希望保留编译前的目录结构。这需要我们修改一些配置项来改变：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)<span class="comment">// 读取流指定base选项可以保留写入流的目录结构</span></span><br><span class="line">        .pipe(transform_sass(&#123; <span class="attr">outputStyle</span>: <span class="string">&#x27;expanded&#x27;</span> &#125;))</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脚本编译"><a href="#脚本编译" class="headerlink" title="脚本编译"></a>脚本编译</h3><p>有时候我们希望使用最新的<code>js</code>语法，就需要使用<code>babel</code>进行编译。或者说我们是用<code>ts</code>等语言进行开发的，也需要进行编译。</p>
<p>安装<a href="https://www.npmjs.com/package/gulp-babel">gulp-babel</a>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Babel 7</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev gulp-babel @babel/core @babel/preset-env</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Babel 6</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev gulp-babel@7 babel-core babel-preset-env</span></span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _babel = <span class="built_in">require</span>(<span class="string">&#x27;gulp-babel&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/scripts/*.js&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(_babel(&#123; <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>] &#125;))</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你使用了<code>ts</code>进行开发，你需要安装<a href="https://www.npmjs.com/package/gulp-typescript">gulp-typescript</a>模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add gulp-typescript typescript --dev </span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ts = <span class="built_in">require</span>(<span class="string">&#x27;gulp-typescript&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> script_ts = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/scripts/*.ts&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(_ts())</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板引擎编译"><a href="#模板引擎编译" class="headerlink" title="模板引擎编译"></a>模板引擎编译</h3><p>模板引擎有多种，需要更具你自己使用的模板语法来选择对应的语法。我们使用到的插件是<a href="https://www.npmjs.com/package/gulp-swig">gulp-swig</a>。</p>
<p>安装：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">yarn add gulp-swig --dev</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pageData = &#123;&#125;; <span class="comment">// 需要根据你编写的模板文件传入相应数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/**/*.html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(_swig(&#123; <span class="attr">data</span>: pageDate &#125;))</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上面的样式编译和脚本编译，就可以组合为一个编译任务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compile = parallel(style, script, page)</span><br></pre></td></tr></table></figure>

<h3 id="图片字体转换"><a href="#图片字体转换" class="headerlink" title="图片字体转换"></a>图片字体转换</h3><p>对于图片、字体等文件，一般来说不需要转译，只需要压缩等操作即可，我们使用<a href="https://www.npmjs.com/package/gulp-imagemin">gulp-imagemin</a>模块。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add gulp-imagemin --dev</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _imagemin = <span class="built_in">require</span>(<span class="string">&#x27;gulp-imagemin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> image = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/images/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(_imagemin())</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> font = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/fonts/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(_imagemin())</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他文件的处理"><a href="#其他文件的处理" class="headerlink" title="其他文件的处理"></a>其他文件的处理</h3><p>比如文件的拷贝、清除等。</p>
<p>这里清除文件可以使用<code>gulp</code>提供的<code>gulp-clean</code>，由于清除文件不需要输出文件，这里也可以使用第三方模块，不走文件流模式，这里我们选择<code>del</code>这个模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clean = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _del([<span class="string">&#x27;dist&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> extra = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;public/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;public&#x27;</span> &#125;)</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合之前写好的编译任务，组合为最终的构建任务<code>build</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compile = parallel(style, script, page, image, font) <span class="comment">// 编译任务</span></span><br><span class="line"><span class="keyword">const</span> build = series(clean, parallel(compile, extra)) <span class="comment">// 构建任务</span></span><br></pre></td></tr></table></figure>

<p>到这里，自动构建的基本已经完成，如果有其他需要，可自行选择插件来自动完成你的任务。</p>
<h3 id="自动加载插件"><a href="#自动加载插件" class="headerlink" title="自动加载插件"></a>自动加载插件</h3><p>随着我们使用的<code>gulp</code>插件越来越多，我们每次使用都需要手动导入插件，这样其实很麻烦，在<code>grunt</code>的使用中，我们使用<code>load-grunt-tasks</code>为我们自动注册配置里的任务项，同样的，<code>gulp</code>中也有一个自动加载插件的插件：<a href="https://www.npmjs.com/package/gulp-load-plugins">gulp-load-plugins</a>。这是非官方插件，目前在gulp插件列表中无法搜索到，这个插件会自动加载你安装的<code>gulp</code>插件，这样我们拿到这个包含所有插件的对象，就能直接使用了。</p>
<p>整合上文使用到的所有任务：（需要注意的是命名问题，比如<code>gulp-babel</code>可以使用<code>plugins.babel</code>获取，而<code>gulp-clean-css</code>这样的插件需要使用<code>plugins.cleanCss</code>来获取）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;src, dest, parallel, series&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> _sass = <span class="built_in">require</span>(<span class="string">&#x27;gulp-sass&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> loadPlugins = <span class="built_in">require</span>(<span class="string">&#x27;gulp-load-plugins&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> _del = <span class="built_in">require</span>(<span class="string">&#x27;del&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = loadPlugins(); <span class="comment">// 加载所有安装的gulp插件</span></span><br><span class="line"><span class="keyword">const</span> pageDate = &#123;&#125;; <span class="comment">// 模板引擎数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 样式编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> style = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)<span class="comment">// 读取流指定base选项可以保留写入流的目录结构</span></span><br><span class="line">        .pipe(_sass(&#123; <span class="attr">outputStyle</span>: <span class="string">&#x27;expanded&#x27;</span> &#125;))</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 脚本编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/scripts/*.js&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(plugins.babel(&#123; <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>] &#125;))</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> script_ts = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/scripts/*.ts&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(plugins.typescript(&#123;</span><br><span class="line">            noImplicitAny: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 模板引擎编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/**/*.html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(plugins.swig(&#123; <span class="attr">data</span>: pageDate &#125;))</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 图片压缩</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> image = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/images/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(plugins.imagemin())</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> font = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/fonts/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;src&#x27;</span> &#125;)</span><br><span class="line">        .pipe(plugins.imagemin())</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 清除目录和文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> clean = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _del([<span class="string">&#x27;dist&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 额外的任务：复制一些必要的文件等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> extra = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;public/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;public&#x27;</span> &#125;)</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;dist&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compile = parallel(style, script, page, image, font)</span><br><span class="line"><span class="keyword">const</span> build = series(clean, parallel(compile, extra))</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    clean,</span><br><span class="line">    compile,</span><br><span class="line">    build,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动服务器"><a href="#启动服务器" class="headerlink" title="启动服务器"></a>启动服务器</h3><p>node服务器插件有很多，这里我们可以使用<code>gulp</code>提供的<a href="https://www.npmjs.com/package/gulp-live-server">gulp-live-server</a>，也可以自由选择。因为不需要使用文件流模式。</p>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> live_server = plugins.liveServer.static(<span class="string">&#x27;dist&#x27;</span>, <span class="number">8080</span>);</span><br><span class="line">    live_server.start();</span><br><span class="line">    done();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如也换成使用比较多的：<a href="https://www.npmjs.com/package/browser-sync">browser-sync</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> server = <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> browserServer = browserSync.create();</span><br><span class="line">    browserServer.init(&#123;</span><br><span class="line">        notify: <span class="literal">false</span>,</span><br><span class="line">        files: <span class="string">&#x27;dist/**&#x27;</span>, <span class="comment">// 监听文件热更新</span></span><br><span class="line">        port: <span class="number">3000</span>,</span><br><span class="line">        server: &#123;</span><br><span class="line">            baseDir: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">            routes: &#123;</span><br><span class="line">                <span class="string">&quot;/node_modules&quot;</span>: <span class="string">&#x27;node_modules&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="文件变化监听"><a href="#文件变化监听" class="headerlink" title="文件变化监听"></a>文件变化监听</h3><p><code>gulp</code>模块提供了文件监听的函数<code>watch</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bs = browserSync.create();</span><br><span class="line">    watch(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, style);</span><br><span class="line">    watch(<span class="string">&#x27;src/assets/scripts/*.js&#x27;</span>, script);</span><br><span class="line">    watch(<span class="string">&#x27;src/**/*.html&#x27;</span>, page);</span><br><span class="line">    <span class="comment">// 静态资源一般无需重新编译，只需要重启服务器即可</span></span><br><span class="line">    watch([</span><br><span class="line">        <span class="string">&#x27;src/assets/images/**&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;src/assets/fonts/**&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;public/**&#x27;</span></span><br><span class="line">    ], bs.reload);</span><br><span class="line"></span><br><span class="line">    bs.init(&#123;</span><br><span class="line">        notify: <span class="literal">false</span>,</span><br><span class="line">        files: <span class="string">&#x27;dist/**&#x27;</span>, <span class="comment">// 监听文件</span></span><br><span class="line">        open: <span class="literal">false</span>,</span><br><span class="line">        port: <span class="number">3000</span>,</span><br><span class="line">        server: &#123;</span><br><span class="line">            baseDir: [<span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;public&#x27;</span>], <span class="comment">// 会依次查找请求资源</span></span><br><span class="line">            routes: &#123;</span><br><span class="line">                <span class="string">&quot;/node_modules&quot;</span>: <span class="string">&#x27;node_modules&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样，我们启动服务器时就能开启监听，实时编译。</p>
<p>这里有个细节问题，其实监听需要编译文件就可以了，服务器无需再监听<code>dist</code>文件，我们可以利用<code>bs.reload</code>重启服务器的方法来改进，类似这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, series(style, bs.reload));</span><br></pre></td></tr></table></figure>

<h3 id="文件引用的处理"><a href="#文件引用的处理" class="headerlink" title="文件引用的处理"></a>文件引用的处理</h3><p>在html代码中，可能引用了一些<code>node_modules</code>目录下的css或者js，类似这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;/node_modules/bootstrap/dist/css/bootstrap.css&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script src=<span class="string">&quot;/node_modules/jquery/dist/jquery.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/node_modules/popper.js/dist/umd/popper.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/node_modules/bootstrap/dist/js/bootstrap.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当我们启动服务器时，如果没有配置路由，是无法访问到这个目录下的文件的。</p>
<p>但是，当我们打包上线的时候，<code>node_modules</code>是不存在的，这样同样无法访问到这些文件，一些办法是我们手动整理这些需要的引用文件，放到要打包的目录下，这样的效率是比较低的，实际上，我们可以使用<code>gulp</code>提供的一个插件来自动处理：<a href="https://www.npmjs.com/package/gulp-useref">gulp-useref</a>。</p>
<p>通过一定规则的html注释，这个插件能将注释包裹的文件引用下的资源自动打包到指定的目录下，这样，就避免了引文文件不存在而找不到文件的问题。</p>
<p>html写法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- build:css assets/styles/vendor.css --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/node_modules/bootstrap/dist/css/bootstrap.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- build:css assets/styles/main.css --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;assets/styles/main.css&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- build:js assets/scripts/vendor.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/node_modules/jquery/dist/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/node_modules/popper.js/dist/umd/popper.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/node_modules/bootstrap/dist/js/bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- build:js assets/scripts/main.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;assets/scripts/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbuild --&gt;</span></span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useref = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;dist/*html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;dist&#x27;</span> &#125;)</span><br><span class="line">        .pipe(plugins.useref(&#123; <span class="attr">searchPath</span>: [<span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;.&#x27;</span>] &#125;)) <span class="comment">// 设置文件查找目录</span></span><br><span class="line">        .pipe(dest(<span class="string">&#x27;release&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：上面的示例中我们把最终的文件放到了<code>release</code>目录下，这样因为如果文件读取流和写入流在同一个文件很可能导致写入失败，而且重写<code>html</code>文件之后，之前的特殊标记都消失了，需要重新编译才能使用<code>useref</code>。</p>
</blockquote>
<p>但是，使用<code>release</code>文件之后，其他很多页面静态编译资源都已经存在了<code>dist</code>目录，所以，当我们使用了<code>useref</code>，就需要使用两个目录进行文件整理：<code>dist目录</code>：一般为最终打包上线的目录，<code>temp</code>目录：缓存目录，开发阶段调试的目录。</p>
<p>首先，useref构建之后的文件是需要上线的，一般我们需要进行压缩代码的操作，但是引文文件包含：css、js还有html，不同的文件类型需要不同的压缩插件，所以我们需要借助<a href="https://www.npmjs.com/package/gulp-if">gulp-if</a>进行流判断操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useref = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;dist/*html&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;dist&#x27;</span> &#125;)</span><br><span class="line">        .pipe(plugins.useref(&#123; <span class="attr">searchPath</span>: [<span class="string">&#x27;dist&#x27;</span>, <span class="string">&#x27;.&#x27;</span>] &#125;))</span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.js$/</span>, plugins.uglify())) <span class="comment">// js压缩</span></span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.css$/</span>, plugins.cleanCss())) <span class="comment">// css压缩</span></span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.html$/</span>, plugins.htmlmin(&#123; <span class="comment">// html压缩</span></span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">            minifyCss: <span class="literal">true</span>,</span><br><span class="line">            minifyJs: <span class="literal">true</span>,</span><br><span class="line">        &#125;)))</span><br><span class="line">        .pipe(dest(<span class="string">&#x27;release&#x27;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是整个文件的目录重新整理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;src, dest, parallel, series, watch&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> _sass = <span class="built_in">require</span>(<span class="string">&#x27;gulp-sass&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> loadPlugins = <span class="built_in">require</span>(<span class="string">&#x27;gulp-load-plugins&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> _del = <span class="built_in">require</span>(<span class="string">&#x27;del&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">&#x27;browser-sync&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = loadPlugins(); <span class="comment">// 加载所有安装的gulp插件</span></span><br><span class="line"><span class="keyword">const</span> pageDate = &#123;&#125;; <span class="comment">// 模板引擎数据</span></span><br><span class="line"><span class="keyword">const</span> srcPath = <span class="string">&#x27;src&#x27;</span>; <span class="comment">// 源文件目录</span></span><br><span class="line"><span class="keyword">const</span> tempPath = <span class="string">&#x27;temp&#x27;</span>; <span class="comment">// 缓存目录，一般用于本地测试时使用</span></span><br><span class="line"><span class="keyword">const</span> distPath = <span class="string">&#x27;dist&#x27;</span>; <span class="comment">// 打包发布目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 清除目录和文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> clean = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _del([tempPath, distPath])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 样式编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> style = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, &#123; <span class="attr">base</span>: srcPath &#125;)<span class="comment">// 读取流指定base选项可以保留写入流的目录结构</span></span><br><span class="line">        .pipe(_sass(&#123; <span class="attr">outputStyle</span>: <span class="string">&#x27;expanded&#x27;</span> &#125;))</span><br><span class="line">        .pipe(dest(tempPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 脚本编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/scripts/*.js&#x27;</span>, &#123; <span class="attr">base</span>: srcPath &#125;)</span><br><span class="line">        .pipe(plugins.babel(&#123; <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>] &#125;))</span><br><span class="line">        .pipe(dest(tempPath))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> script_ts = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/scripts/*.ts&#x27;</span>, &#123; <span class="attr">base</span>: srcPath &#125;)</span><br><span class="line">        .pipe(plugins.typescript(&#123;</span><br><span class="line">            noImplicitAny: <span class="literal">true</span>,</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(dest(tempPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 模板引擎编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/**/*.html&#x27;</span>, &#123; <span class="attr">base</span>: srcPath &#125;)</span><br><span class="line">        .pipe(plugins.swig(&#123; <span class="attr">data</span>: pageDate, <span class="attr">cache</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">        .pipe(dest(tempPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 图片压缩</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> image = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/images/**&#x27;</span>, &#123; <span class="attr">base</span>: srcPath &#125;)</span><br><span class="line">        .pipe(plugins.imagemin())</span><br><span class="line">        .pipe(dest(distPath))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> font = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;src/assets/fonts/**&#x27;</span>, &#123; <span class="attr">base</span>: srcPath &#125;)</span><br><span class="line">        .pipe(plugins.imagemin())</span><br><span class="line">        .pipe(dest(distPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 额外的任务：复制一些必要的文件等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> extra = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;public/**&#x27;</span>, &#123; <span class="attr">base</span>: <span class="string">&#x27;public&#x27;</span> &#125;)</span><br><span class="line">        .pipe(dest(distPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="function">(<span class="params">done</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bs = browserSync.create();</span><br><span class="line">    watch(<span class="string">&#x27;src/assets/styles/*.scss&#x27;</span>, series(style, bs.reload));</span><br><span class="line">    watch(<span class="string">&#x27;src/assets/scripts/*.js&#x27;</span>, series(script, bs.reload));</span><br><span class="line">    watch(<span class="string">&#x27;src/**/*.html&#x27;</span>, series(page, bs.reload));</span><br><span class="line">    <span class="comment">// 静态资源一般无需重新编译，只需要重启服务器即可</span></span><br><span class="line">    watch([</span><br><span class="line">        <span class="string">&#x27;src/assets/images/**&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;src/assets/fonts/**&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;public/**&#x27;</span></span><br><span class="line">    ], bs.reload);</span><br><span class="line"></span><br><span class="line">    bs.init(&#123;</span><br><span class="line">        notify: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// files: &#x27;dist/**&#x27;, // 监听文件</span></span><br><span class="line">        open: <span class="literal">false</span>,</span><br><span class="line">        port: <span class="number">3000</span>,</span><br><span class="line">        server: &#123;</span><br><span class="line">            baseDir: [tempPath, srcPath, <span class="string">&#x27;public&#x27;</span>], <span class="comment">// 会依次查找请求资源</span></span><br><span class="line">            routes: &#123;</span><br><span class="line">                <span class="string">&quot;/node_modules&quot;</span>: <span class="string">&#x27;node_modules&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * useref:文件引用处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> useref = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&#x27;temp/*html&#x27;</span>, &#123; <span class="attr">base</span>: tempPath &#125;)</span><br><span class="line">        .pipe(plugins.useref(&#123; <span class="attr">searchPath</span>: [tempPath, <span class="string">&#x27;.&#x27;</span>] &#125;))</span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.js$/</span>, plugins.uglify())) <span class="comment">// js压缩</span></span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.css$/</span>, plugins.cleanCss())) <span class="comment">// css压缩</span></span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.html$/</span>, plugins.htmlmin(&#123; <span class="comment">// html压缩</span></span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">            minifyCss: <span class="literal">true</span>,</span><br><span class="line">            minifyJs: <span class="literal">true</span>,</span><br><span class="line">        &#125;)))</span><br><span class="line">        .pipe(dest(distPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务组合</span></span><br><span class="line"><span class="keyword">const</span> compile = parallel(style, script, page)</span><br><span class="line"><span class="keyword">const</span> develop = series(clean, compile, server)</span><br><span class="line"><span class="keyword">const</span> build = series(clean, parallel(compile, image, font, extra), useref)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    clean,</span><br><span class="line">    develop,</span><br><span class="line">    build,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了方便测试，我们一般还需要在<code>package.json</code>的添加<code>scripts</code>信息:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;clean&quot;: &quot;gulp clean&quot;,</span><br><span class="line">  &quot;develop&quot;: &quot;gulp develop&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;gulp build&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要上传到git，需要忽略自动构建文件夹：<code>dist</code>和<code>temp</code>。</p>
<h2 id="封装自动构建工作流脚手架"><a href="#封装自动构建工作流脚手架" class="headerlink" title="封装自动构建工作流脚手架"></a>封装自动构建工作流脚手架</h2><p>上面的自动化是比较常用的，我们可以封装为自己的脚手架，便于下次直接使用，我们可以创建一个基于<code>yeoman</code>之类的脚手架，也可以直接把整个文件放到<code>git</code>远程仓库。脚手架的好处是支持cli用户个性化设置，本质上也只是文件的复制工作，为了这个模块更通用，我们需要把<code>gulpfile.js</code>文件进行路径、配置的提取，便于使用者修改配置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;src, dest, parallel, series, watch&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> _del = <span class="built_in">require</span>(<span class="string">&#x27;del&#x27;</span>)    <span class="comment">// 文件移除模块</span></span><br><span class="line"><span class="keyword">const</span> &#123; join &#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> loadPlugins = <span class="built_in">require</span>(<span class="string">&#x27;gulp-load-plugins&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> browserSync = <span class="built_in">require</span>(<span class="string">&#x27;browser-sync&#x27;</span>) <span class="comment">// 服务器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plugins = loadPlugins(); <span class="comment">// 加载所有本地已安装的gulp插件</span></span><br><span class="line"><span class="comment">// 文件配置项(用户自定义)</span></span><br><span class="line"><span class="keyword">const</span> default_userConfig = &#123;</span><br><span class="line">    build: &#123; <span class="comment">// 构建项目的路径配置</span></span><br><span class="line">        srcPath: <span class="string">&#x27;src&#x27;</span>,</span><br><span class="line">        tempPath: <span class="string">&#x27;temp&#x27;</span>,</span><br><span class="line">        distPath: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        publicPath: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">        srcPaths: &#123;</span><br><span class="line">            styles: <span class="string">&#x27;assets/styles/*.scss&#x27;</span>,</span><br><span class="line">            scripts: <span class="string">&#x27;assets/scripts/*.js&#x27;</span>,</span><br><span class="line">            script_ts: <span class="string">&#x27;assets/scripts/*.ts&#x27;</span>,</span><br><span class="line">            pages: <span class="string">&#x27;*.html&#x27;</span>,</span><br><span class="line">            images: <span class="string">&#x27;assets/images/**&#x27;</span>,</span><br><span class="line">            fonts: <span class="string">&#x27;assets/fonts/**&#x27;</span>,</span><br><span class="line">            public: <span class="string">&#x27;**&#x27;</span>, <span class="comment">// cwd: publicPath</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    pageDate: &#123;&#125;, <span class="comment">// 模板引擎数据</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> userConfig = <span class="built_in">Object</span>.assign(&#123;&#125;, default_userConfig, <span class="built_in">require</span>(<span class="string">&#x27;./userConfig&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pathBuild = userConfig.build;</span><br><span class="line"><span class="keyword">const</span> srcPaths = pathBuild.srcPaths;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 样式编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> style = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(srcPaths.styles, &#123; <span class="attr">base</span>: pathBuild.srcPath, <span class="attr">cwd</span>:  pathBuild.srcPath&#125;)</span><br><span class="line">        .pipe(plugins.sass(&#123; <span class="attr">outputStyle</span>: <span class="string">&#x27;expanded&#x27;</span> &#125;))</span><br><span class="line">        .pipe(dest(pathBuild.tempPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 脚本编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> script = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(srcPaths.scripts, &#123; <span class="attr">base</span>: pathBuild.srcPath, <span class="attr">cwd</span>:  pathBuild.srcPath&#125;)</span><br><span class="line">        .pipe(plugins.babel(&#123; <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>] &#125;))</span><br><span class="line">        .pipe(dest(pathBuild.tempPath))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> script_ts = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(srcPaths.script_ts, &#123; <span class="attr">base</span>: pathBuild.srcPath, <span class="attr">cwd</span>:  pathBuild.srcPath&#125;)</span><br><span class="line">        .pipe(plugins.typescript( &#123; <span class="attr">noImplicitAny</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">        .pipe(dest(pathBuild.tempPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 模板引擎编译</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(srcPaths.pages, &#123; <span class="attr">base</span>: pathBuild.srcPath, <span class="attr">cwd</span>:  pathBuild.srcPath&#125;)</span><br><span class="line">        .pipe(plugins.swig(&#123; <span class="attr">data</span>: userConfig.pageDate, <span class="attr">cache</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">        .pipe(dest(pathBuild.tempPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 图片压缩</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> image = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(srcPaths.images, &#123; <span class="attr">base</span>: pathBuild.srcPath, <span class="attr">cwd</span>:  pathBuild.srcPath&#125;)</span><br><span class="line">        .pipe(plugins.imagemin())</span><br><span class="line">        .pipe(dest(pathBuild.distPath))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> font = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(srcPaths.fonts, &#123; <span class="attr">base</span>: pathBuild.srcPath, <span class="attr">cwd</span>:  pathBuild.srcPath&#125;)</span><br><span class="line">        .pipe(plugins.imagemin())</span><br><span class="line">        .pipe(dest(pathBuild.distPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 额外的任务：复制一些必要的文件等</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> extra = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> src(srcPaths.public, &#123; <span class="attr">base</span>: pathBuild.publicPath, <span class="attr">cwd</span>:  pathBuild.publicPath&#125;)</span><br><span class="line">        .pipe(dest(pathBuild.distPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bs = browserSync.create();</span><br><span class="line">    <span class="keyword">const</span> opts = &#123; <span class="attr">cwd</span>: pathBuild.srcPath &#125;;</span><br><span class="line">    <span class="comment">// 编译文件监控</span></span><br><span class="line">    watch(srcPaths.styles, opts, series(style, bs.reload));</span><br><span class="line">    watch(srcPaths.scripts, opts, series(script, bs.reload));</span><br><span class="line">    watch(srcPaths.script_ts, opts, series(script_ts, bs.reload));</span><br><span class="line">    watch(srcPaths.pages, opts, series(page, bs.reload));</span><br><span class="line">    <span class="comment">// 静态资源一般无需重新编译，只需要重启服务器即可</span></span><br><span class="line">    watch([</span><br><span class="line">        srcPaths.pages,</span><br><span class="line">        srcPaths.fonts,</span><br><span class="line">        srcPaths.public,</span><br><span class="line">    ], opts , bs.reload);</span><br><span class="line"></span><br><span class="line">    bs.init(&#123;</span><br><span class="line">        notify: <span class="literal">false</span>,</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">3000</span>,</span><br><span class="line">        server: &#123;</span><br><span class="line">            baseDir: [pathBuild.tempPath, pathBuild.srcPath, pathBuild.publicPath], <span class="comment">// 依次查找请求资源路径</span></span><br><span class="line">            routes: &#123; <span class="comment">// 路由</span></span><br><span class="line">                <span class="string">&quot;/node_modules&quot;</span>: <span class="string">&#x27;node_modules&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 清除目录和文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> clean = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _del([pathBuild.tempPath, pathBuild.distPath])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * useref:文件引用处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> useref = <span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> src(join(pathBuild.tempPath, srcPaths.pages), &#123; <span class="attr">base</span>: pathBuild.tempPath&#125;)</span><br><span class="line">        .pipe(plugins.useref(&#123; <span class="attr">searchPath</span>: [pathBuild.tempPath, <span class="string">&#x27;.&#x27;</span>] &#125;))</span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.js$/</span>, plugins.uglify())) <span class="comment">// js压缩</span></span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.css$/</span>, plugins.cleanCss())) <span class="comment">// css压缩</span></span><br><span class="line">        .pipe(plugins.if(<span class="regexp">/\.html$/</span>, plugins.htmlmin(&#123; <span class="comment">// html压缩</span></span><br><span class="line">            collapseWhitespace: <span class="literal">true</span>,</span><br><span class="line">            minifyCss: <span class="literal">true</span>,</span><br><span class="line">            minifyJs: <span class="literal">true</span>,</span><br><span class="line">        &#125;)))</span><br><span class="line">        .pipe(dest(pathBuild.distPath))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务组合</span></span><br><span class="line"><span class="keyword">const</span> compile = parallel(style, script, script_ts, page)</span><br><span class="line"><span class="keyword">const</span> develop = series(clean, compile, server)</span><br><span class="line"><span class="keyword">const</span> build = series(clean, parallel(compile, image, font, extra), useref)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    clean,</span><br><span class="line">    dev: develop,</span><br><span class="line">    build,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件中引用的<code>userConfig</code>就是为了用户能更好地自定义文件目录，我们可以通过使用脚手架时初始化文件目录，以及这个配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    build: &#123; <span class="comment">// 构建项目的路径配置</span></span><br><span class="line">        srcPath: <span class="string">&#x27;src&#x27;</span>,</span><br><span class="line">        tempPath: <span class="string">&#x27;.temp&#x27;</span>,</span><br><span class="line">        distPath: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">        publicPath: <span class="string">&#x27;public&#x27;</span>,</span><br><span class="line">        srcPaths: &#123;</span><br><span class="line">            styles: <span class="string">&#x27;assets/styles/*.scss&#x27;</span>,</span><br><span class="line">            scripts: <span class="string">&#x27;assets/scripts/*.js&#x27;</span>,</span><br><span class="line">            script_ts: <span class="string">&#x27;assets/scripts/*.ts&#x27;</span>,</span><br><span class="line">            pages: <span class="string">&#x27;*.html&#x27;</span>,</span><br><span class="line">            images: <span class="string">&#x27;assets/images/**&#x27;</span>,</span><br><span class="line">            fonts: <span class="string">&#x27;assets/fonts/**&#x27;</span>,</span><br><span class="line">            public: <span class="string">&#x27;**&#x27;</span>, <span class="comment">// cwd: publicPath</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    pageDate: &#123;&#125;, <span class="comment">// 模板引擎数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果你使用的是<code>yeoman</code>搭建的脚手架，可以参考下面的处理逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> generators = <span class="built_in">require</span>(<span class="string">&#x27;yeoman-generator&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">generators</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cli用户自定义配置(待优化)</span></span><br><span class="line">    prompting()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.prompt([&#123;</span><br><span class="line">            type: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">            message : <span class="string">&#x27;Your project name&#x27;</span>,</span><br><span class="line">            <span class="keyword">default</span> : <span class="built_in">this</span>.appname</span><br><span class="line">        &#125;]).then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.answers = answers;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成文件</span></span><br><span class="line">    writing() &#123;</span><br><span class="line">         <span class="comment">// 模板路径</span></span><br><span class="line">        <span class="keyword">const</span> tempDir = path.join(__dirname, <span class="string">&#x27;templates&#x27;</span>);</span><br><span class="line">         <span class="comment">// 输出路径</span></span><br><span class="line">        <span class="keyword">const</span> destDir = process.cwd();</span><br><span class="line">        <span class="comment">// 模板上下文数据</span></span><br><span class="line">        <span class="keyword">const</span> ejsData = &#123;</span><br><span class="line">            title: <span class="built_in">this</span>.answers[<span class="string">&#x27;name&#x27;</span>],</span><br><span class="line">            success: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 模板文件写入</span></span><br><span class="line">        fs.readdir(tempDir, <span class="function">(<span class="params">err, files</span>) =&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            files.forEach(<span class="function"><span class="params">temp</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> input = path.join(tempDir, temp);</span><br><span class="line">                <span class="keyword">const</span> output = path.join(destDir, temp);</span><br><span class="line">                <span class="built_in">this</span>.fs.copyTpl(input, output, ejsData);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fis的使用"><a href="#Fis的使用" class="headerlink" title="Fis的使用"></a>Fis的使用</h2><p>百度团队开发的一款自动化构建工具，有兴趣的可参考：<a href="http://fis.baidu.com/">http://fis.baidu.com/</a>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程范式</title>
    <url>/2020/09/27/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>函数式编程是很早就出现的一种编程范式，就像面向过程编程、面向对象编程一样，函数式编程作为一种编程范式，有自己的关注重点和编程理念。</p>
<blockquote>
<p><strong>函数式编程</strong>（英语：<strong>functional programming</strong>）或称<strong>函数程序设计</strong>、<strong>泛函编程</strong>，是一种<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F">编程范式</a>，它将<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E9%81%8B%E7%AE%97">电脑运算</a>视为<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>运算，并且避免使用<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A8%8B%E5%BC%8F%E7%8A%B6%E6%80%81&action=edit&redlink=1">程序状态</a>以及<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6">易变对象</a>。其中，<a href="https://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97">λ演算</a>（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。</p>
</blockquote>
<p><img data-src="/images/function.png" alt="function"></p>
<p>本文将结合<code>js语言</code>梳理函数式编程的理念、函数的一些特点、函数式编程的基本概念以及函子的应用，如：高阶函数、闭包、纯函数、柯里化、函数组合、常用的一些函子等。</p>
<a id="more"></a>

<h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p>编程范式也就是一种编程风格，编程范型提供了（同时决定了）<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%91%98">程序员</a>对<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>执行的看法。例如，在<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a>中，程序员认为程序是<strong>一系列相互作用的对象</strong>，而在<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>中一个程序会被看作是一个<strong>无状态的函数计算的序列</strong>。</p>
<p>比如：<strong>面向过程编程</strong>的关注重点在于事件完成的方法、步骤，因为计算机的执行就是一条一条执行执行的，也很符合计算机的运算逻辑，但这种编程方式不适合我们用代码去“表达”和理解这个世界，而面向对象编程则以“<strong>万物皆为对象</strong>”为准则，某件事的实现只是某些对象的行为组合而已，比如我们要实现一个五子棋的游戏，从面向过程的逻辑来说，我们一般需要进过这些步骤：</p>
<ol>
<li>游戏开始</li>
<li>玩家A落子</li>
<li>判断游戏是否结束，是则执行步骤7</li>
<li>未结束则玩家B落子</li>
<li>判断游戏是否结束，是则执行步骤7</li>
<li>未结束则回到步骤2</li>
<li>游戏结束</li>
</ol>
<p>程序的执行逻辑确实是首位的，但我们可以从不同的角度的理解来实现，对于面向对象来说，玩家A和玩家B都属于同一类对象，我们可以称为玩家，玩家都有落子这一行为，本程序中还有游戏本身我们也看作一个对象，游戏有开始、结束的行为、记录棋谱的行为以及判断游戏是否结束的逻辑，当然你还可以把棋子看作一个对象，这取决于你希望封装这个对象来干嘛。我们封装一个对象除了能更好地<strong>理解程序逻辑</strong>之外，还能更好地使用继承和实现来<strong>复用代码</strong>。所以上面的五子棋游戏用面向对象的描述就是：游戏开始后，两个玩家轮流执行落子这一行为，每次落子都会触发游戏判断本轮游戏是否结束的行为，未结束则继续落子，直到游戏结束。</p>
<p>而本文要讲的<strong>函数式编程</strong>重点在于把某个操作步骤抽象为一个<strong>只关心输入和输出的函数（映射）</strong>，而与程序本身无关，这有点像数学中函数的概念：<code>f(x)</code>，我们输入某个参数，一定会得到某个输出，且不管在什么环境下都不会发生变化，即<strong>与状态无关</strong>，这就是输入输出之间的映射关系。</p>
<p>函数式编程可以让我们最大程度的<strong>复用代码</strong>，<strong>由于函数式编程注重无状态以及无副作用</strong>，在使用这种函是我们可以直接调用，而无需关心代码执行状态和代码之间数据的联系。</p>
<p>如果说万物皆对象，那么万物也都有一些不变的公理和定理，面向对象编程具象了某个实例，而函数式编程抽象了对象中的某种客观规律，就比如从宏观角度来说，万物皆有万有引力定律一般，这些定律在一定条件下是固定不变的，我们就可以抽象为一个函数。</p>
<p>不管是什么样的编程范式，都是不冲突的，都只是我们对程序的理解角度不同而已，我们应当各取所长，综合不同的场景使用，而不是追求和极致的使用某一种编程风格：</p>
<ul>
<li><strong>面向过程编程</strong>是解决问题的关键，可以让我们专注于<strong>算法</strong>的优化</li>
<li><strong>面向对象编程</strong>让我们更好的梳理程序之间的<strong>逻辑关系</strong>，实现更好的扩展思路。</li>
<li><strong>函数式编程</strong>的无状态特点是其最大的优点，理论上，可以在任意场景下使用，类似<code>Math.sin</code>这种函数，我们无需关心数据之间千丝万缕的联系，我们只想得到数据对应的映射关系，本质上也就<strong>提高了代码的复用性和降低了代码之间耦合性</strong>（可以说直接切断了耦合）。</li>
</ul>
<h2 id="函数式编程的特点"><a href="#函数式编程的特点" class="headerlink" title="函数式编程的特点"></a>函数式编程的特点</h2><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>一等公民很好理解，就是作为程序设计语言世界的一员，拥有最多的权利（特权）。函数是一定公民的意思也就是函数在该程序语言中拥有一等的使用特权：别的成员有的特性，函数也有，别的成员没有的特性，函数也可能有。</p>
<p>函数作为一等公民，一般有以下特点：</p>
<ul>
<li>函数可以作为编程存储在变量中</li>
<li>函数可以作为参数传递</li>
<li>函数可以作为返回值</li>
</ul>
<p>实际上，在<code>JavaScript</code>中，函数就是一个普通的对象，所以我们可以通过<code>new Function</code>的方式创建一个该函数对象的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数作为变量存储</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作为参数传入</span></span><br><span class="line"><span class="keyword">const</span> re = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(sum);</span><br><span class="line"><span class="built_in">console</span>.log(re) <span class="comment">// [1,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作为返回值</span></span><br><span class="line"><span class="keyword">const</span> Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.`</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.say())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数作为一等公民的函数又称为<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0">头等函数</a>。</p>
</blockquote>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6">数学</a>和<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>高阶函数</strong>是至少满足下列一个条件的<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>：</p>
<ul>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
<p>一句话就是高阶函数允许接收至少一个函数作为参数或者返回一个函数作为输出。</p>
<p>高阶函数可以让我们组合多个普通函数，也就是<strong>让函数更抽象</strong>，屏蔽了执行细节，我们只需关注输入和输出。</p>
<p>现在我们来手动实现数组中的几个高阶函数来具体感受一下：<code>map</code>、<code>every</code>、<code>some</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>];</span><br><span class="line"><span class="comment">// map的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newArr = [];</span><br><span class="line">    arr.forEach(<span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">        newArr.push(fn(a));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pow2Arr = map(arr, <span class="function"><span class="params">a</span> =&gt;</span> a ** <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(pow2Arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// every的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">every</span>(<span class="params">arr, fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!fn(a)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(every(arr, <span class="function"><span class="params">a</span> =&gt;</span> a % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(every(arr, <span class="function"><span class="params">a</span> =&gt;</span> a &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// some的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">some</span>(<span class="params">arr, fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fn(a)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(some(arr, <span class="function"><span class="params">a</span> =&gt;</span> a % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line"><span class="built_in">console</span>.log(some(arr, <span class="function"><span class="params">a</span> =&gt;</span> a &gt; <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<h3 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h3><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>闭包</strong>（英语：Closure），又称<strong>词法闭包</strong>（Lexical Closure）或<strong>函数闭包</strong>（function closures），是在支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0">头等函数</a>的编程语言中实现<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F#%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F">词法</a><a href="https://en.wikipedia.org/wiki/Name_binding">绑定</a>的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。</p>
</blockquote>
<p>闭包在定义上有很多的专业术语，描述也很抽象，我们需要在大量使用中感受闭包的概念。我们先理解一些基本的概念：</p>
<ul>
<li><p>头等函数：也就是上文所讲的“函数是一等公民”：函数作为变量存储，可以作为函数的参数或返回值来引用。</p>
</li>
<li><p>词法作用域：也称为<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F#%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F">静态作用域</a>，静态作用域在编译时就已经确定了该词法变量的作用域范围（也就是词法和实体引用的生效范围）。比如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>foo</code>拥有两个变量<code>a</code>和<code>bar</code>，其中<code>bar</code>是一个函数，我们就说<code>a</code>和<code>bar</code>的作用域在<code>foo</code>函数内生效，也就是js中所说的函数作用域。而<code>bar</code>中也有自己的变量<code>b</code>，同样的，<code>b</code>变量只在<code>bar</code>函数作用域中生效，也就是<code>foo</code>无法访问变量<code>b</code>。</p>
</li>
<li><p>执行环境：执行环境就是调用该语句时所处的作用域。</p>
</li>
</ul>
<p>我们再次来观察闭包的定义：闭包则实际上是一个<strong>函数的实例</strong>，也就是说它是存在于内存里的某个<strong>结构体</strong>，函数就是一种结构体，但是不是所有函数我们都称为闭包，它还需要满足最关键的一点：具有包含<strong>环境成分</strong>和<strong>控制成分</strong>的实体。（<a href="https://zh.wikipedia.org/wiki/%E5%BD%BC%E5%BE%97%C2%B7%E5%85%B0%E4%B8%81">彼得·兰丁</a>（Peter Landin）1964所定义）。</p>
<p>用不严谨但是更具体的话来总结就是：闭包是对其周围状态（词法环境）和引用（执行环境）具有绑定关系的函数实例。</p>
<p>我们以下面的代码为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = foo();</span><br><span class="line"><span class="keyword">const</span> d = c();</span><br></pre></td></tr></table></figure>

<ul>
<li>变量<code>c</code>是函数<code>foo</code>的实例，<code>foo</code>返回了内部函数<code>bar</code>的引用，所以<code>c</code>指向函数<code>bar</code>。</li>
<li><code>bar</code>的词法环境，也就是内部变量<code>a</code>和<code>b</code>的作用域分别是<code>foo</code>和本身<code>bar</code>。</li>
<li>而函数<code>bar</code>在调用时执行环境变成了全局作用域，因为引用<code>c</code>的词法作用域是全局作用域。</li>
<li>综上可知：<code>bar</code>函数的<strong>执行环境</strong>为全局作用域，<strong>词法环境</strong>包括<code>foo</code>函数作用域和<code>bar</code>函数本身的作用域。</li>
<li>理论上，全局作用域是不能访问函数作用域的，但是<code>bar</code>的执行环境就是全局作用域，并且访问到了它的词法作用域，也就是函数作用域，这样，我们就说函数<code>bar</code>的执行环境和词法环境有了绑定关系，也就符合了闭包的定义，所以被引用的<code>bar</code>函数体就是一个闭包。</li>
</ul>
<p>即，闭包可以建立起执行环境和词法环境之间的绑定关系，也就让本不能访问函数作用域的全局作用域能进行访问。</p>
<blockquote>
<p>在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。所以上面的例子中<code>foo</code>执行后并不会被回收，就是因为有变量<code>c</code>引用了<code>bar</code>，而<code>bar</code>又引用了<code>foo</code>，当变量<code>c</code>被回收后，<code>foo</code>才会被回收。</p>
<p>因此，如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为<strong>闭包在处理速度和内存消耗方面对脚本性能具有负面影响</strong>。</p>
</blockquote>
<p>更多细节可参考：<a href="https://web.archive.org/web/20100825182303/http://www.felixwoo.com/archives/247">深入理解Javascript闭包(closure) - Felix Woo</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包 - MDN</a>。</p>
<h2 id="函数式编程中的一些基本概念"><a href="#函数式编程中的一些基本概念" class="headerlink" title="函数式编程中的一些基本概念"></a>函数式编程中的一些基本概念</h2><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>在提到函数式编程时，我们一再强调函数式编程关注的<strong>无状态和无副作用</strong>两个重点，而纯函数就是这样一种函数。</p>
<p>在<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">程序设计</a>中，若一个<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F#%E5%87%BD%E6%95%B8">函数</a>符合以下要求，则它可能被认为是<strong>纯函数</strong>：</p>
<ul>
<li><strong>相同的输入，一定会有相同的输出</strong>。函数的输出和输入值以外的其他隐藏信息或<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A8%8B%E5%BC%8F%E7%8B%80%E6%85%8B&action=edit&redlink=1">状态</a>无关，也和由<a href="https://zh.wikipedia.org/wiki/I/O">I/O</a>设备产生的外部输出无关。</li>
<li><strong>无副作用</strong>。该函数不能有语义上可观察的<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%89%AF%E4%BD%9C%E7%94%A8">函数副作用</a>，诸如“触发事件”，使输出设备输出，或更改输出值以外物件的内容等。</li>
</ul>
<p>第一条对应无状态特性，执行状态不会影响输出结果，即不管执行环境是什么，相同的输入总会有相同的输出，就相当于求和函数：输入<code>1,2</code>,输出一定是<code>3</code>。第二条无副作用一般指，整个函数的执行过程<strong>不会造成其他外部数据的变化</strong>，即不会改变外部执行环境。</p>
<p>其实两个要求总结来说就两个关键词：外部执行环境和输入输出，外部执行环境不会影响输出值，计算输出值的过程同样不会改变外部执行环境，因而称为纯函数。</p>
<p>比如说js中的数据原型函数：<code>slice</code>就是纯函数，但<code>splice</code>就是不纯的函数，因为<code>splice</code>在截取数组之后会改变原数组，也就是执行环境发生了变化，函数产生了副作用。</p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>柯里化一个以人名命名的<strong>函数技术</strong>，要了解背后的原理，我们先观察一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求b的a次方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">power</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ** a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="number">2</span>, <span class="number">4</span>)) <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(power(<span class="number">2</span>, <span class="number">5</span>)) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p><code>power</code>函数是计算<code>b的a次方</code>的一个函数，有时候我们会多次使用到<strong>求平方</strong>这样的函数，也就是参数<code>a</code>为<code>2</code>时的函数。这样我们可以把参数<code>a</code>固定为2，并返回一个函数，这个函数就变得更实用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求b的a次方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">power</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ** a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">power2</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> power(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(power2(<span class="number">3</span>)) <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(power2(<span class="number">4</span>)) <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">console</span>.log(power2(<span class="number">5</span>)) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就称<code>power</code>到<code>power2</code>的过程为柯里化。</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>柯里化</strong>（英语：Currying），又译为<strong>卡瑞化</strong>或<strong>加里化</strong>，是把接受多个<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E6%95%B8_(%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88)">参数</a>的<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由<a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%87%8C%E6%96%AF%E6%89%98%E5%BC%97%C2%B7%E6%96%AF%E7%89%B9%E9%9B%B7%E5%A5%87">克里斯托弗·斯特雷奇</a>以逻辑学家<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E6%96%AF%E5%87%B1%E7%88%BE%C2%B7%E5%8A%A0%E9%87%8C">哈斯凯尔·加里</a>命名的，尽管它是<a href="https://zh.wikipedia.org/w/index.php?title=Moses_Sch%C3%B6nfinkel&action=edit&redlink=1">Moses Schönfinkel</a>和<a href="https://zh.wikipedia.org/wiki/%E6%88%88%E7%89%B9%E6%B4%9B%E5%B8%83%C2%B7%E5%BC%97%E9%9B%B7%E6%A0%BC">戈特洛布·弗雷格</a>发明的。</p>
<p>在直觉上，柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数”。所以对于有两个变量的函数<img data-src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a2751277797e1414968ac33ad9d4a26cb9f8a601" alt="y^{x}">，如果固定了<img data-src="https://wikimedia.org/api/rest_v1/media/math/render/svg/099cab48854e883602b8f188d4972969d2cf567b" alt="y=2">，则得到有一个变量的函数<img data-src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5514b506cd3af97484bca3e166965ac4cef27a02" alt="2^{x}">。</p>
</blockquote>
<p><strong>柯里化</strong>是一种<strong>处理函数中附有多个参数的方法</strong>，并在只允许单一参数的框架中使用这些函数。例如，一些分析技术只能用于具有单一参数的函数。现实中的函数往往有更多的参数。弗雷格表明，为单一参数情况提供解决方案已经足够了，因为可以将具有多个参数的函数转换为一个单参数的函数链。这种转变是现在被称为“柯里化”的过程。</p>
<p>简言之，我们把处理<strong>多参数函数转换为更少参数函数的方法</strong>称为柯里化。</p>
<p>上面的实例中，我们来封装一个更适用的柯里化函数，通过这个函数，我们就能得到<code>power2</code>、<code>power3</code>等等类型的单一参数函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 柯里化后的power函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryPower</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b ** a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> power2 = curryPower(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> power3 = curryPower(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(power2(<span class="number">3</span>)) <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(power3(<span class="number">3</span>)) <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<h4 id="柯里化函数的实现"><a href="#柯里化函数的实现" class="headerlink" title="柯里化函数的实现"></a>柯里化函数的实现</h4><p>柯里化函数，也就是某个函数<code>fn</code>，当我们<strong>传入部分参数</strong>，返回值就是只具有<strong>剩余参数</strong>的<code>fn</code>子函数（注：这里的子函数只是一个称谓，比如我们可以说<code>2的b次方</code>是<code>a的b次方</code>的子类，也就是次方关系中的一种情况）。现在我们就来实现把普通函数变为柯里化函数的<strong>工具函数</strong>：</p>
<ul>
<li>语法：<code>curryFun = curry(func)</code></li>
<li>参数：普通函数<code>func</code></li>
<li>返回值：柯里化函数<code>curryFun</code></li>
<li>功能：把普通函数<code>func</code>封装为柯里化函数<code>curryFun</code>，返回的<code>curryFun</code>可以接受至少一个参数，如果接受的参数已经满足<code>func</code>，直接返回<code>func()</code>的执行结果，如果还有剩余参数，则返回以剩余参数作为参数的<code>func</code>函数的子函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...a</span>)</span>&#123; <span class="comment">// 传入的参数</span></span><br><span class="line">        <span class="keyword">const</span> len = func.length; <span class="comment">// 形参的数量</span></span><br><span class="line">        <span class="keyword">if</span>(a.length &gt;= len) <span class="keyword">return</span> func(...a); <span class="comment">// 情况一：参数满足func，直接返回计算结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...b</span>)</span>&#123;  <span class="comment">// 情况二：还有剩余参数:返回子类函数</span></span><br><span class="line">            <span class="keyword">return</span> func(...a.concat(b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在JavaScript工具库<a href="https://www.lodashjs.com/">lodash</a>中已经实现了类似的柯里化工具函数：<code>curry</code>。</p>
</blockquote>
<p>现在，我们来简单测试一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通求和函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化的求和函数</span></span><br><span class="line"><span class="keyword">const</span> curry_sum = curry(sum);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(curry_sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curry_sum(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(curry_sum(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得注意的是，当函数参数小于2以及<strong>参数不确定时</strong>是无法柯里化的。</p>
</blockquote>
<h3 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h3><p>我们使用纯函数和柯里化函数后很容易写出“<strong>洋葱代码</strong>”，类似<code>f(g(h(x)))</code>这种层次包裹的函数，这其实是不利于代码阅读的，这种层层包裹的函数就像是一条<strong>数据管道</strong>：<code>h(x)</code> → <code>g(y) → f(z)</code>。数据经过层层传递，最终才变成了最后的输出结果。这条由多个函数组合而成的<strong>管道</strong>，我们就可以统称为一个函数<code>w(x)</code>，那么<code>w(x)</code>就与<code>f(g(h(x)))</code>无异，但更能便于我们阅读和修改组合体，这种由多个函数依次处理并传递数据的形成的新函数就称为组合函数。</p>
<p>现在我们来实现一个<strong>接收多个函数，返回一个组合函数</strong>的工具函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = funcs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            arg = funcs[i](arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> funcs.reverse().reduce(<span class="function">(<span class="params">data, fn</span>) =&gt;</span> fn(data), arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有几个值得关注的点：</p>
<ul>
<li>在洋葱函数中，执行顺序为从内而外，即<strong>从右往左</strong>依次执行，比如<code>f(g(h(x)))</code>，所以我们在实现组合函数时参数按照从左到右的<strong>书写顺序</strong>，但<strong>执行顺序</strong>却是从右往左</li>
<li>组合函数中的每一个函数的参数都为<code>1</code>位，这点尤其需要注意，多参数的情况下我们需要柯里化为一个参数的函数。</li>
<li><code>lodash</code>工具库中已实现了类似的组合函数，名为<code>flowRight</code>。</li>
</ul>
</blockquote>
<p>简单的测试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _ = <span class="built_in">require</span>(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收多个函数，返回一个组合函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = funcs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            arg = funcs[i](arg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = compose(_.toUpper, join, _.reverse)</span><br><span class="line"><span class="built_in">console</span>.log(f([<span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>组合函数相当于几个有固定的执行顺序的函数组合，所以满足<strong>结合律</strong>的特性，比如<code>compose(a,b,c)</code>和<code>compose(a,compose(b,c))</code>是无差异的。组合函数虽然方便阅读，但也屏蔽了内部细节，在执行结果出错时，我们一般很难凭肉眼找到问题，我们就可以在组合函数中间<strong>插入调试函数</strong>，来展示或者检测是否符合预期，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调试函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showResult</span>(<span class="params">func, result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(func.name, <span class="string">&#x27;的执行结果为：&#x27;</span>, result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 柯里化的调试函数</span></span><br><span class="line"><span class="keyword">const</span> curry_show = _.curry(showResult);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = compose(_.toUpper, curry_show(_.join), join, curry_show(_.reverse), _.reverse)</span><br><span class="line"><span class="built_in">console</span>.log(f([<span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse 的执行结果为： [ &#x27;hello&#x27;, &#x27;world&#x27; ]</span></span><br><span class="line"><span class="comment">// join 的执行结果为： hello world</span></span><br><span class="line"><span class="comment">// HELLO WORLD</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数组合的过程是一种<strong>无数据的合成运算</strong>，即我们不需要关心处理的数据的（输入和输出），只关心需要合成的函数以及执行顺序，这种编程风格我们又称为“<strong>pointfree</strong>”，即无值风格。</p>
</blockquote>
<h2 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>还是那句话，函数式编程的关注点在于追求无状态和无副作用两个特性，但很多时候，数据来源或者输出都取决于用户IO操作，或者某些未知的异步操作等等。这种时候函数就很可能变得不纯，我们要做的只是尽可能的<strong>让数据变得可控</strong>，编程中的<code>函子设计理念</code>能让我们更好地<strong>让数据在有效范围得到控制</strong>。函子（<code>Functor</code>）是<a href="https://zh.wikipedia.org/wiki/%E7%AF%84%E7%96%87_(%E6%95%B8%E5%AD%B8)">范畴学</a>中的一个概念：</p>
<blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E7%AF%84%E7%96%87%E8%AB%96">范畴论</a>中，<strong>函子</strong>是范畴间的一类映射。</p>
</blockquote>
<p>说到映射，自然而然就想到了函数，实际上，函子就是<strong>一种特别的函数</strong>。函子的定义十分抽象，且有各种专业术语，这里我们通过代码上的使用来感受函子的设计理念即可，感兴趣的可自行参考<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%AD%90">函子 - wiki</a>。</p>
<p>在代码设计中，函子通常表示为一个具有以下功能的<strong>容器</strong>：（这个容易你可以立即为对象，也可以理解为特殊的函数）</p>
<ul>
<li>包含一个不对外暴露的值<code>value</code>。</li>
<li>实现一个<code>map</code>接口（契约），该接口接收一个自定义函数<code>Fn</code>用于处理<code>value</code>值，并返回一个<code>Fn</code>处理后的值作为<code>value</code>的新函子容器。即需要实现这样的<code>map</code> 接口：<ul>
<li>语法：<code>map(fn)</code></li>
<li>参数<code>fn</code>：用于处理函子容器的<code>value</code>值，得到<code>new_value</code>。</li>
<li>返回值：一个以<code>new_value</code>作为容器值的新函子容器。</li>
</ul>
</li>
</ul>
<p>函子在范畴学中定义为一类映射，上面的<code>fn</code>就是相当于其中一个映射，当我们再次使用新函子进行<code>map</code>调用时，又会得到一个新的<code>fn</code>，这些<code>fn</code>组合起来就是所谓的一类映射：（有点类似上文说的函数组合，所以函子也是符合结合律的）</p>
<h3 id="函子的实现"><a href="#函子的实现" class="headerlink" title="函子的实现"></a>函子的实现</h3><p>更具上面的定义，我们用一个类来实现函子（你可以使用普通Object，也可以使用函数来实现，都无差别）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个简单的函子容器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span>(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map(fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(fn(<span class="built_in">this</span>._value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：由于<code>value</code>是私有变量 ，不对外暴露（当然，js目前并不支持私有变量，你也可以使用<code>symbol</code>来实现一个私有属性），在使用时，我们常常为了优雅，不直接使用<code>new</code>来创建函子对象，而是提供一个<code>of</code>的静态变量进行创建。</p>
</blockquote>
<p>我们现在来测试一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = Container.of([<span class="string">&#x27;world&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line">    .map(_.reverse)</span><br><span class="line">    .map(join)</span><br><span class="line">    .map(_.toUpper);</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// Container &#123; _value: &#x27;HELLO WORLD&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p>这里的测试代码其实就是上文我们测试<code>函数组合</code>一模一样的代码，可以发现，函子和函数组合都<strong>是链式执行函数的一种结构</strong>。不同在于，函子容器的链式调用可以让我们更方便组合调用函数直接的关系，以及可以<strong>修改函子容器，让其具有一些特定的功能</strong>，以此来更好地进行全局控制数据异常，避免调用过程中的数据副作用。</p>
<p>比如上面的案例中，由于传入的数据可能并不可靠，就会导致数据变得不纯，比如传入的数组是空对象或者空参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = Container.of(<span class="literal">undefined</span>)</span><br><span class="line">    .map(_.reverse)</span><br><span class="line">    .map(join)</span><br><span class="line">    .map(_.toUpper);</span><br></pre></td></tr></table></figure>

<p>那么执行过程就会发生错误而变得不纯：<code>TypeError: Cannot read property &#39;join&#39; of undefined</code>。</p>
<p>针对不同的应用场景，我们可以<strong>对普通的函子进行改造</strong>，也可以称为限定范畴，以此来控制一定范畴数据变得可控：比如常见的<code>MayBe函子</code>、<code>Monad函子</code>，下面会一一说明这些具有特定功能的函子。</p>
<h3 id="MayBe函子"><a href="#MayBe函子" class="headerlink" title="MayBe函子"></a>MayBe函子</h3><p><code>MayBe</code>函子就是<strong>对空值数据的进行处理</strong>的一种函子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MayBe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span>(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MayBe(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map(fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MayBe(<span class="built_in">this</span>.isNull ? <span class="literal">null</span> : fn(<span class="built_in">this</span>._value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isNull() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.is(<span class="built_in">this</span>._value, <span class="literal">null</span>) || <span class="built_in">Object</span>.is(<span class="built_in">this</span>._value, <span class="literal">undefined</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，我们对普通函子进行了简单的改造，新增了一个<code>isNull</code>方法，当数据判断为空值时，就直接返回<code>null</code>作为新容器的值，而无需执行函数调用，也就避免了错误的发生。</p>
<h3 id="IO函子"><a href="#IO函子" class="headerlink" title="IO函子"></a>IO函子</h3><p>除了数据回导致函数变得不纯，某些异步操作异常也会让函数变得不纯，比如一些异步<code>IO</code>操作，这里所谓的<code>IO</code>函子就是把这一系列异步操作都组合到<code>_value</code>中，也就是把<code>_value</code>变成一个组合函数，这样，我们需要手动调用一下<code>_value</code>函数才会开始执行，也就相当于<strong>把可能不纯的函数延迟执行</strong>，让调用者手动调用时才触发，一定程度上让执行变得可控：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (fn) &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = fn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span>(value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IO(<span class="function">() =&gt;</span> value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map(fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IO(_.flowRight(fn, <span class="built_in">this</span>._value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>IO</code>函子其实就是函子和组合函数的结合使用案例，函子的<code>_value</code>为序列<code>map</code>参数的组合函数。</p>
<p>由于<code>_value</code>是一个函数，为了获取返回值，我们提供一个<code>run</code>方法来获取执行结果。（<code>run</code>执行是调用者手动触发的，可以更好地控制异常发生的位置）。</p>
</blockquote>
<p>比如我们在<code>Node</code>环境下获取当前进程的绝对执行路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = IO.of(process).map(<span class="function"><span class="params">p</span> =&gt;</span> p.execPath)</span><br><span class="line"><span class="built_in">console</span>.log(c.run()) <span class="comment">// C:\Program Files\nodejs\node.exe</span></span><br></pre></td></tr></table></figure>

<h3 id="Task函子"><a href="#Task函子" class="headerlink" title="Task函子"></a>Task函子</h3><p>一种专门处理异步函数的函子。在<a href="https://folktale.origamitower.com/docs/v2.0.0/">folktale</a>这个库中已经实现了<code>Task</code>函子，我们安装并体验一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; task &#125; = <span class="built_in">require</span>(<span class="string">&#x27;folktale/concurrency/task&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 一个task函子化的readFile</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task(<span class="function"><span class="params">resolver</span> =&gt;</span> &#123;</span><br><span class="line">        fs.readFile(filePath, <span class="string">&#x27;utf-8&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) resolver.reject(err);</span><br><span class="line">            resolver.resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">    .run()</span><br><span class="line">    .listen(&#123;</span><br><span class="line">        onRejected: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err.Error);</span><br><span class="line">        &#125;,</span><br><span class="line">        onResolved: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>task</code>函数有点类似<code>promise</code>对象，具体使用细节我们可以参考官方文档：<a href="https://folktale.origamitower.com/docs/v2.3.0/migrating/from-data.task/">task</a>。</p>
</blockquote>
<p>这样，我们就可以在<code>onResolved</code>中拿到异步函数的返回值，如果我们在这个函数中处理返回值，那就不是所谓的函数式编程了（我们应该使用函数来处理，而非直接对外暴露细节），也没有体现函子的使用特性。实际上，<code>task</code>函子化函数可以接收系列的<code>map</code>来处理异步函数接受到的数据，最后才传递给<code>listen</code>，就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line">readFile(<span class="string">&#x27;package.json&#x27;</span>)</span><br><span class="line">    .map(<span class="built_in">JSON</span>.parse)</span><br><span class="line">    .map(<span class="function"><span class="params">data</span> =&gt;</span> data.version)</span><br><span class="line">    .run()</span><br><span class="line">    .listen(&#123;</span><br><span class="line">        onRejected: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err.Error);</span><br><span class="line">        &#125;,</span><br><span class="line">        onResolved: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data); <span class="comment">// 1.0.0</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>这样，最终接收到的数据就是<code>map</code>处理后的数据。</p>
<h3 id="Pointed函子"><a href="#Pointed函子" class="headerlink" title="Pointed函子"></a>Pointed函子</h3><p>就是一个简单的概念：实现了<code>of</code>静态接口的函子，也就是我们上面一直在使用的方法。</p>
<h3 id="Monad函子"><a href="#Monad函子" class="headerlink" title="Monad函子"></a>Monad函子</h3><p>我们先观察一个现象：我们定义了两个<code>reverse</code>和<code>upper</code>函数，这两个函数都是函子函数，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最简单的pointed函子</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(val) &#123;</span><br><span class="line">        <span class="built_in">this</span>._val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span>(val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(val);</span><br><span class="line">    &#125;</span><br><span class="line">    map(fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(fn(<span class="built_in">this</span>._val));</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = [<span class="string">&#x27;jinx&#x27;</span>, <span class="string">&#x27;yasuo&#x27;</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Container.of(arr).map(_.reverse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upper</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Container.of(str).map(_.toUpper);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = reverse(data).map(upper)</span><br><span class="line"><span class="built_in">console</span>.log(c.run().run())</span><br></pre></td></tr></table></figure>

<p>现象就是，当我们使用函子作为<code>map</code>的参数时，就会发生<strong>函子嵌套</strong>现象，这时我们如果需要获取数据，就需要层层调用<code>run()</code>方法，这样的写法是极不友好的。</p>
<p>类似洋葱函数的不友好一样，我们使用组合函数解决了函数层层包裹的问题，同样的，面对函子层层嵌套的问题，我们可以使用<code>Monad函子</code>进行函子扁平化处理。</p>
<p>其实原理很简单，就是在<code>map</code>中传递函子时，我们手动调用一下<code>run</code>方法，以此来直接获取<code>value</code>作为传递值，为了和<code>map</code>做区分，我们可以使用新的函数名<code>flatMap</code>,<code>Monad</code>函子看起来就会像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(val) &#123;</span><br><span class="line">        <span class="built_in">this</span>._val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span>(val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(val);</span><br><span class="line">    &#125;</span><br><span class="line">    map(fn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(fn(<span class="built_in">this</span>._val));</span><br><span class="line">    &#125;</span><br><span class="line">    flatMap(container) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Container(container(<span class="built_in">this</span>._val).run());</span><br><span class="line">    &#125;</span><br><span class="line">    run() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = reverse(data).flatMap(upper)</span><br><span class="line"><span class="built_in">console</span>.log(c.run()) <span class="comment">// 只用执行一次</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实就是在<code>map</code>的<code>fn</code>后面自动执行了<code>run()</code>作为返回值。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>函数式编程作为一种编程范式，追求一种<strong>无状态和无副作用</strong>的函数编程。涉及到的概念主要分为：</p>
<ul>
<li>支持函数式编程的基本<strong>特点</strong>：<ul>
<li>函数是一等公民</li>
<li>支持高阶函数</li>
<li>可闭包</li>
</ul>
</li>
<li>函数式编程的<strong>理念</strong>：<ul>
<li>纯函数</li>
<li>柯里化</li>
<li>管道与函数组合</li>
</ul>
</li>
<li>函数式编程的更好的<strong>数据控制</strong>：使用各种类型的函子。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://web.archive.org/web/20100825182303/http://www.felixwoo.com/archives/247">深入理解Javascript闭包(closure) - Felix Woo</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包 - MDN</a></li>
<li><a href="https://www.zcfy.cc/article/functors-amp-categories-javascript-scene-medium-2698.html">函子和范畴</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript新特性</title>
    <url>/2020/09/13/ECMAScript%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p><code>ECMAScript</code>是<code>JavaScript</code>语言的规范，从2011年的<code>ES5</code>.1到2015年的<code>ES6</code>跨度比较大，这个版本更新的内容也是最多的，由此，本文主要针对<code>ES6</code>提出的新特性和新方法进行梳理归纳。</p>
<p><img data-src="/images/ecmascript.png"></p>
<a id="more"></a>

<h2 id="什么是ECMAScript"><a href="#什么是ECMAScript" class="headerlink" title="什么是ECMAScript"></a>什么是<code>ECMAScript</code></h2><blockquote>
<p><strong>ECMAScript</strong>是一种由<a href="https://zh.wikipedia.org/wiki/Ecma%E5%9B%BD%E9%99%85">Ecma国际</a>（前身为<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%B4%B2%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%B6%E9%80%A0%E5%95%86%E5%8D%8F%E4%BC%9A">欧洲计算机制造商协会</a>）在标准ECMA-262中定义的<a href="https://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>规范。这种语言在<a href="https://zh.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91">万维网</a>上应用广泛，它往往被称为<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>或<a href="https://zh.wikipedia.org/wiki/JScript">JScript</a>，但实际上后两者是ECMA-262标准的<strong>实现和扩展</strong>。</p>
</blockquote>
<p>ECMAScript是由<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E6%99%AF%E5%85%AC%E5%8F%B8">网景</a>的<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E8%98%AD%E7%99%BB%C2%B7%E8%89%BE%E5%85%8B">布兰登·艾克</a>开发的一种脚本语言的标准化规范；最初命名为Mocha，后来改名为LiveScript，最后重命名为JavaScript[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-1">1]</a>。1995年12月，<a href="https://zh.wikipedia.org/wiki/%E6%98%87%E9%99%BD%E9%9B%BB%E8%85%A6%E5%85%AC%E5%8F%B8">升阳</a>与网景联合发表了JavaScript[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-2">2]</a>。1996年11月，网景公司将JavaScript提交给欧洲计算机制造商协会进行标准化。ECMA-262的第一个版本于1997年6月被Ecma组织采纳。ECMAScript是由ECMA-262标准化的脚本语言的名称。</p>
<p>尽管JavaScript和JScript与ECMAScript兼容，但包含超出ECMAScript的功能[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-3">3]</a>。</p>
<p>通常，js又有web端和node本地两种实现：</p>
<p>在浏览器端或者说web端，<code>javaScript</code>包含了：</p>
<ul>
<li>ECMAScript。</li>
<li>Web API，即<code>Bom</code> 和 <code>Dom</code>两部分。</li>
</ul>
<p>在<code>Node.js</code>中的<code>javaScript</code>包含了：</p>
<ul>
<li>ECMAScript。</li>
<li>Node API，包含<code>fs</code>模块、<code>net</code>模块等等。</li>
</ul>
<blockquote>
<p>所以说<code>javaScript</code>是<code>ecmaScript</code>的实现与扩展，扩展的部分就是提供的各种api。</p>
</blockquote>
<h2 id="ECMAScript的发展历程"><a href="#ECMAScript的发展历程" class="headerlink" title="ECMAScript的发展历程"></a><code>ECMAScript</code>的发展历程</h2><p>从1997年发布以来，es的迭代版本信息主要为：</p>
<table>
<thead>
<tr>
<th align="center">版本</th>
<th align="center">发表日期</th>
<th align="center">与前版本的差异</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1997年6月</td>
<td align="center">首版</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1998年6月</td>
<td align="center">格式修正，以使得其形式与ISO/IEC16262国际标准一致</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1999年12月</td>
<td align="center">强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">放弃</td>
<td align="center">由于关于语言的复杂性出现分歧，第4版本被放弃，其中的部分成为了第5版本及Harmony的基础</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">2009年12月</td>
<td align="center">新增“严格模式（strict mode）”，一个子集用作提供更彻底的错误检查,以避免结构出错。澄清了许多第3版本的模糊规范，并适应了与规范不一致的真实世界实现的行为。增加了部分新功能，如getters及setters，支持<a href="https://zh.wikipedia.org/wiki/JSON">JSON</a>以及在对象属性上更完整的<a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%B0%84_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">反射</a>[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-4">4]</a>[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-5">5]</a>[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-6">6]</a>[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-7">7]</a>[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-8">8]</a></td>
</tr>
<tr>
<td align="center">5.1</td>
<td align="center">2011年6月</td>
<td align="center">ECMAScript标5.1版形式上完全一致于国际标准ISO/IEC 16262:2011。</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">2015年6月</td>
<td align="center">ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony。</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">2016年6月</td>
<td align="center">ECMAScript 2016（ES2016），第 7 版，多个新的概念和语言特性[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-ES2016-9">9]</a></td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">2017年6月</td>
<td align="center">ECMAScript 2017（ES2017），第 8 版，多个新的概念和语言特性[<a href="https://zh.wikipedia.org/wiki/ECMAScript#cite_note-:0-10">10]</a></td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">2018年6月</td>
<td align="center">ECMAScript 2018 （ES2018），第 9 版，包含了异步循环，生成器，新的正则表达式特性和 rest/spread 语法。</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">2019年6月</td>
<td align="center">ECMAScript 2019 （ES2019），第 10 版</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">2020年6月</td>
<td align="center">ECMAScript 2020 （ES2020），第 11 版</td>
</tr>
</tbody></table>
<p>从上面的版本更迭中有个特殊的阶段，就是2011年的<code>es5.1</code>到2015年的<code>es6</code>，由于间隔年份较大，语法和使用特性上的变化也最大，<code>ECMAScript2015</code>的新特性在<code>ES5.1</code>的基础上做了大量的优化，所以这也是本文将要探讨的内容。</p>
<h2 id="let和const与var的区别"><a href="#let和const与var的区别" class="headerlink" title="let和const与var的区别"></a><code>let</code>和<code>const</code>与<code>var</code>的区别</h2><p><code>let</code>和<code>const</code>都是<code>ES6</code>新增的变量申明关键字。与<code>var</code>最主要的不同之处在于，<strong>变量作用域的不同</strong>。</p>
<p>在<code>ES6</code>之前，<code>js</code>的作用域一般分为：全局作用域和函数作用域。这样，有时候我们在使用回调函数等场景时往往由于变量的作用域问题，而不得不使用闭包特性来解决变量属于函数作用域的问题。</p>
<p>典型的一个问题，在循环中闭包的使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    elements[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">elements[<span class="number">0</span>].onClick()  <span class="comment">// 3</span></span><br><span class="line">elements[<span class="number">1</span>].onClick()  <span class="comment">// 3</span></span><br><span class="line">elements[<span class="number">2</span>].onClick()  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>我们构建了elements的<code>onClick</code>函数并手动触发，但我们发现，给自的打印结果都是<code>3</code>，而不是我们预期的<code>0, 1, 2</code>。</p>
<p>原因是赋值给<code>onClick</code>函数的是闭包，而这个参数<code>i</code>是函数作用域，闭包指向的也就是循环结束后最终的<code>i</code>值。</p>
<p>解决这个问题，我们需要再使用一层闭包，将<code>i</code>作为参数时的作用域不再是<code>for</code>循环中的函数作用域，而属于当前闭包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eleClick</span>(<span class="params">elements, i</span>) </span>&#123;</span><br><span class="line">    elements[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> elements = [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    eleClick(elements, i);</span><br><span class="line">&#125;</span><br><span class="line">elements[<span class="number">0</span>].onClick()  <span class="comment">// 0</span></span><br><span class="line">elements[<span class="number">1</span>].onClick()  <span class="comment">// 1</span></span><br><span class="line">elements[<span class="number">2</span>].onClick()  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就创建了一个<code>eleClick</code>函数来应用闭包特性，也就独立维护了参数<code>i</code>的作用域，不再是外层函数的作用域。</p>
<p>当然，可能我们更常使用匿名闭包，但都是一个原理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        elements[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，有了<code>es6</code>提供的<code>let</code>变量申明关键字，我们不需要再使用闭包。除了上面说的全局作用局和函数作用域，<code>es6</code>新增了<strong>块级作用域</strong>的概念，即更小单位的作用域，一般的代码块都可以拥有自己的变量作用域，比如一个循环体内部，一个<code>if else</code>代码块内部，一个<code>try catch</code>代码块内部，代码块中的变量将不会自动变量提升，作用域只属于当前代码块，<strong>使用<code>let</code>或者<code>const</code>申明的变量就是块级作用域变量</strong>。</p>
<p>我们将上面的循环案例中的<code>var</code>换成<code>let</code>试试看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = [&#123;&#125;, &#123;&#125;, &#123;&#125;]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">    elements[i].onClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">elements[<span class="number">0</span>].onClick()  <span class="comment">// 0</span></span><br><span class="line">elements[<span class="number">1</span>].onClick()  <span class="comment">// 1</span></span><br><span class="line">elements[<span class="number">2</span>].onClick()  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>效果显而易见，我们只是将<code>i</code>声明为块作用域，这时，<code>i</code>是只能在循环这个代码块中访问的，所以变量也不会提升，自然不会在循环结束后保留<code>i = 3</code>，而且在循环外部我们将无法再访问这个变量。</p>
<p>总结<code>let</code>与<code>var</code>的<strong>区别就是</strong>：作用域不同，<code>let</code>申明的变量是块级作用域，而<code>var</code>申明的变量是函数作用域，且能自动提升（即可以使用后申明）。</p>
<p>而<code>const</code>也是块级作用域，与<code>let</code>的区别是，<code>const</code>是<strong>只读变量</strong>申明，即申明的时候就需要初始化变量，且后续<strong>不能进行赋值</strong>操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// hello</span></span><br><span class="line">    a = <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const也是块级作用域，在外部使用会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>最佳实践</strong>，建议<strong>不再使用</strong><code>var</code>，主用<code>const</code>，搭配使用<code>let</code>。</p>
</blockquote>
<h2 id="数组和对象的解构赋值"><a href="#数组和对象的解构赋值" class="headerlink" title="数组和对象的解构赋值"></a>数组和对象的解构赋值</h2><blockquote>
<p><strong>解构赋值</strong>是<code>ES6</code>提出的一种新语法，通过<strong>解构赋值,</strong> 可以将属性/值从对象/数组中取出,赋值给其他变量。</p>
</blockquote>
<p>对象和数组逐个对应表达式，或称对象字面量和数组字面量，提供了一种简单的定义一个特定的数据组的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>解构赋值使用了相同的语法，不同的是在表达式左边定义了要从原变量中取出什么变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr <span class="comment">// 对数组arr进行解构</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>上面的例子已经很浅显的表示了解构的基本语法，我们只需要<strong>在赋值表达式左边使用相同的装箱构造</strong>就能达到解构的目的。</p>
<p>左边的构造会和右边的数据一一对应，并逐一进行赋值。</p>
<p>有时候数组太长，我们只希望<strong>解构其中部分数据</strong>可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解构部分</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [a, , c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>有时候数组过长，可以<strong>将剩余数组赋值给一个变量</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, ...c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// [3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>还可以给解构时的变量<strong>设置默认值</strong>（当解构赋值的值为<code>undefined</code>时会使用默认值）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, c=<span class="number">0</span>] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>使用数组解构的特性，我们还能用来<strong>交换变量</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b, a]</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，这里的<code>;</code>不写会报Cannot access ‘b’ before initialization的错误。算是一个小bug?</p>
</blockquote>
<p>利用解构的特性，我们可以<strong>复制一个数组</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> [...arr2] = arr</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 0, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [ 1, 2, 3 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>和数组的解构一样，我们在表达式左边书写对象的封装表达即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Json&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;name, age&#125; = obj <span class="comment">// 对象的解构</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Json</span></span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>注意，我们使用<strong>对象的键</strong>作为解构赋值的提取关键字和变量名，可能存在这样的情况，<strong>关键字已经被占用了</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Zoom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Json&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>: name2, age&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Zoom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2) <span class="comment">// Json</span></span><br></pre></td></tr></table></figure>

<p>同样，我们也能<strong>设置默认值</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;<span class="attr">name</span>: name2 = <span class="string">&#x27;&#x27;</span>, age = <span class="number">0</span>&#125; = obj</span><br></pre></td></tr></table></figure>

<p>有时候对象里嵌套了数组，我们同样能进行嵌套解构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    hobbies: [<span class="string">&#x27;reading&#x27;</span>, <span class="string">&#x27;gaming&#x27;</span>, <span class="string">&#x27;coding&#x27;</span>],</span><br><span class="line">    info: &#123;</span><br><span class="line">        name: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">        age: <span class="number">28</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    hobbies: [h1, h2, h3],</span><br><span class="line">    info: &#123;</span><br><span class="line">        name,</span><br><span class="line">        age,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125; = obj</span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="built_in">console</span>.log(h1) <span class="comment">// reading</span></span><br><span class="line"><span class="built_in">console</span>.log(h2) <span class="comment">// gaming</span></span><br><span class="line"><span class="built_in">console</span>.log(h3) <span class="comment">// coding</span></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// Jinx</span></span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">// 28</span></span><br></pre></td></tr></table></figure>

<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><blockquote>
<p><strong>模板字面量</strong>是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。它们在ES2015规范的先前版本中被称为<strong>“模板字符串</strong>“。</p>
<p>我们使用符号 <strong>`</strong> 将字符串包裹起来即可。</p>
</blockquote>
<p>使用模板字符串表示多行字符串，能<strong>保留原有的格式</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = </span><br><span class="line"><span class="string">`晚风吹尽 荷花叶 任我醉倒在池边</span></span><br><span class="line"><span class="string">等你清除看见我的美 月光晒成眼泪`</span></span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br></pre></td></tr></table></figure>

<p>更方便的地方在于，我们能使用<strong>插值表达式</strong>进行字符串构造：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    age = <span class="number">24</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`I&#x27;m <span class="subst">$&#123;name&#125;</span>, I am <span class="subst">$&#123;age&#125;</span> years old.`</span>) <span class="comment">// I&#x27;m Jinx, I am 24 years old.</span></span><br></pre></td></tr></table></figure>

<p>更高级的一种用法是：<strong>带标签的模板字符串</strong>，标签使您可以<strong>用函数解析模板字符串</strong>。</p>
<p>标签函数的第一个参数包含一个字符串值的数组。其余的参数与表达式相关。最后，你的函数可以返回处理好的的字符串（或者它可以返回完全不同的东西）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="string">&#x27;Mike&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTag</span>(<span class="params">strings, personExp, ageExp</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> str0 = strings[<span class="number">0</span>]; <span class="comment">// &quot;that &quot;</span></span><br><span class="line">  <span class="keyword">const</span> str1 = strings[<span class="number">1</span>]; <span class="comment">// &quot; is a &quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ageStr = ageExp &gt; <span class="number">99</span> ? <span class="string">&#x27;centenarian&#x27;</span> : <span class="string">&#x27;youngster&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str0 + personExp + str1 + ageStr;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = myTag<span class="string">`that <span class="subst">$&#123; person &#125;</span> is a <span class="subst">$&#123; age &#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output); <span class="comment">// that Mike is a youngster</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串的扩展方法"><a href="#字符串的扩展方法" class="headerlink" title="字符串的扩展方法"></a>字符串的扩展方法</h2><blockquote>
<p><code>ES2015</code>新增三个字符串的原型方法：includes、startsWith、endsWith。</p>
</blockquote>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h3><blockquote>
<p>这个方法可以帮你判断一个字符串是否包含另外一个字符串。</p>
<p>语法：str.includes(searchString[, position])</p>
<ul>
<li><p>searchString：搜索的字符串</p>
</li>
<li><p>position：从当前字符串的哪个索引位置开始搜寻子字符串，默认值为 <code>0</code>。</p>
</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;Blue Whale&#x27;</span>.includes(<span class="string">&#x27;blue&#x27;</span>); <span class="comment">// return false</span></span><br></pre></td></tr></table></figure>

<p>注：和数组的<code>includes</code>的用法一致。</p>
<h3 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h3><blockquote>
<p>这个方法用来判断字符串是否以某个字符串开头。</p>
<p>语法：str.startWidth(searchString[, startPosition])</p>
<p>变量意义同<code>includs</code>一样。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Blue Whale&#x27;</span>.startsWith(<span class="string">&#x27;Blue&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Blue Whale&#x27;</span>.startsWith(<span class="string">&#x27;lue&#x27;</span>, <span class="number">1</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h3><blockquote>
<p>这个方法用来判断字符串是否以某个字符串开头。</p>
<p>语法：str.startWidth(searchString[, endPosition])</p>
<p>不同的是，endPosition是规定结束的位置，默认为字符串长度。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Blue Whale&#x27;</span>.endsWith(<span class="string">&#x27;ale&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Blue Whale&#x27;</span>.endsWith(<span class="string">&#x27;ue&#x27;</span>, <span class="number">4</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>在ES2015之前，我们常常需要在函数内部进行参数默认值赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">    num1 = num1 === <span class="literal">undefined</span> ? <span class="number">0</span> : num1;</span><br><span class="line">    num2 = num2 === <span class="literal">undefined</span> ? <span class="number">0</span> : num2;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>有了默认参数值这种语法结构，我们可以更为简单的书写代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1=<span class="number">0</span>, num2=<span class="number">0</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>值得注意的是，带有默认值的参数必须写在非默认参数的后面。</p>
</blockquote>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><p>当我们申明一个未知参数数量的函数时，我们常常使用内置的类数组对象<code>arguments</code>来接受所有参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).forEach(<span class="function"><span class="params">arg</span> =&gt;</span> &#123;</span><br><span class="line">        n += arg;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>而ES6提供了一种新的<strong>展开语法</strong>，使用<code>...</code> 可以让我们直接封装剩余参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num = <span class="number">0</span>, ...others</span>)</span>&#123;</span><br><span class="line">    others.forEach(<span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">        num += n;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>剩余参数会将多余未接受的参数放到一个数组中，最为一个参数传递到函数中。</p>
</blockquote>
<h2 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符..."></a>展开操作符<code>...</code></h2><p>上面我们已经提到了剩余参数就是使用<code>...</code>来实现的。此外<code>...</code>操作符还有别的用法。</p>
<p>比如我们想要循环打印一个数组，你可能会这样来操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印方法1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>], arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 打印方法2</span></span><br><span class="line"><span class="built_in">console</span>.log.apply(<span class="built_in">this</span>, arr);</span><br></pre></td></tr></table></figure>

<p>有了展开操作符，我们可以直接这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(...arr);</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><blockquote>
<p><strong>箭头函数表达式</strong>的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>
</blockquote>
<p>让你的代码<strong>更简洁优美</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> add2 = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调箭头函数</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(<span class="function"><span class="params">n</span> =&gt;</span> num += n)</span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p><strong>没有单独的<code>this</code>对象</strong></p>
<p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值：</p>
<ul>
<li>如果是该函数是一个构造函数，this指针指向一个新的对象</li>
<li>在严格模式下的函数调用下，this指向undefined</li>
<li>如果是该函数是一个对象的方法，则它的this指针指向这个对象</li>
<li>等等</li>
</ul>
<p><code>this</code>被证明是令人厌烦的面向对象风格的编程。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Person() 构造函数定义 `this`作为它自己的实例.</span></span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在非严格模式, growUp()函数定义 `this`作为全局对象, </span></span><br><span class="line">    <span class="comment">// 与在 Person()构造函数中定义的 `this`并不相同.</span></span><br><span class="line">    <span class="built_in">this</span>.age++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>而通过箭头函数来书写可以解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">  that.age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 回调引用的是`that`变量, 其值是预期的对象.</span></span><br><span class="line">    that.age++;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p><strong>通过 call 或 apply 调用</strong>时需要注意：由于 箭头函数没有自己的this指针，通过 <code>call()</code> <em>或</em> <code>apply()</code> 方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  base : <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">  add : <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base;</span><br><span class="line">    <span class="keyword">return</span> f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="built_in">this</span>.base;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      base : <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure>

<p>其他需要注意的点：</p>
<ul>
<li><p>箭头函数不绑定<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments">Arguments 对象</a>。因此，<code>arguments</code>只是引用了封闭作用域内的。</p>
</li>
<li><p>箭头函数不能用作构造器，和 <code>new</code>一起用会抛出错误。</p>
</li>
<li><p>箭头函数没有<code>prototype</code>属性。</p>
</li>
<li><p><code>yield</code> 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。</p>
</li>
<li><p>写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="params">x</span> =&gt;</span> x * x;                  </span><br><span class="line"><span class="comment">// 简写函数 省略return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123; <span class="keyword">return</span> x + y; &#125;; </span><br><span class="line"><span class="comment">//常规编写 明确的返回值</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对象字面量的增强"><a href="#对象字面量的增强" class="headerlink" title="对象字面量的增强"></a>对象字面量的增强</h2><p>在<code>ES6</code>之前，我们在构建对象时需要严格按照键值对的写法：<code>key: value</code>，现在我们可以更简洁自由得书写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Jinx&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">22</span>;</span><br><span class="line"><span class="comment">// 增强写法1</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增强写法2</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;haha&#x27;</span></span><br><span class="line">obj[[key]] = <span class="string">&#x27;hehe&#x27;</span> <span class="comment">// 我们可以在[]内写一些表达式</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.key) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.haha) <span class="comment">// hehe</span></span><br></pre></td></tr></table></figure>

<h2 id="Object的新增的一些方法"><a href="#Object的新增的一些方法" class="headerlink" title="Object的新增的一些方法"></a>Object的新增的一些方法</h2><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><blockquote>
<p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="built_in">Object</span> &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;</span><br></pre></td></tr></table></figure>

<p>借此，我们可以用来<strong>拷贝一个对象</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objCopy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br></pre></td></tr></table></figure>

<p>但需要注意的是，针对深拷贝，需要使用其他办法，因为 <code>Object.assign()</code><strong>拷贝的是（可枚举）属性值。</strong></p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h3><blockquote>
<p><code>Object.is()</code> 方法判断两个值是否为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">同一个值</a>。</p>
</blockquote>
<p>判断两个值是否相等，我们常常使用<code>==</code>或者<code>===</code>来判断，那这个<code>Object.is</code>又有什么不同呢？</p>
<p><code>Object.is</code>的规则如下：</p>
<ul>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a></li>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a></li>
<li>都是 <code>true</code> 或 <code>false</code></li>
<li>都是相同长度的字符串且相同字符按相同顺序排列</li>
<li>都是相同对象（意味着每个对象有同一个引用）</li>
<li>都是数字且<ul>
<li>都是 <code>+0</code></li>
<li>都是 <code>-0</code></li>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a></li>
<li>或都是非零而且非 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> 且为同一个值</li>
</ul>
</li>
</ul>
<p>对于严格比较运算符（<code>===</code>）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（<code>==</code>）来说，会在进行比较之前，将两个操作数转换成相同的类型。</p>
<p>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality"><code>==</code></a> 运算<em>不同。</em> <code>==</code> 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 <code>&quot;&quot; == false</code> 判断为 <code>true</code>), 而 <code>Object.is</code>不会强制转换两边的值。</p>
<p>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity"><code>===</code></a> 运算也不相同。 <code>===</code> 运算符 (也包括 <code>==</code> 运算符) 将数字 <code>-0</code> 和 <code>+0</code> 视为相等 ，而将<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN"><code>Number.NaN</code></a> 与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>视为不相等.</p>
<p><strong>简单来说</strong>，<code>Object.is</code>与<code>===</code>严格程度很接近，但不同在于<code>-0</code>和<code>+0</code>前者视为不等，后者视为相等；而对于<code>NaN</code>则是前者视为相等，后者视为不等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span> === <span class="number">-0</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="代理对象Proxy"><a href="#代理对象Proxy" class="headerlink" title="代理对象Proxy"></a>代理对象Proxy</h2><blockquote>
<p><strong>Proxy</strong> 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。</p>
</blockquote>
<p><code>proxy</code>是<strong>代理</strong>的意思，正如引用描述的一样，<strong>Proxy</strong> 对象用于定义基本操作的自定义行为，即我们可以使用<strong>Proxy</strong>来自定义基本操作，也就达到了监听数据变化的作用。</p>
<blockquote>
<p><strong>语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<ul>
<li>target：<strong>被 Proxy 代理虚拟化的对象</strong>。它常被作为代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。要使用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li>
<li>handler：包含捕捉器（trap）的占位符对象，可译为处理器对象。一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>p</code> 的行为。</li>
</ul>
</blockquote>
<p><code>handler</code> 对象是一个容纳一批特定属性的占位符对象。它包含有 <code>Proxy</code> 的各个捕获器（trap）。</p>
<h3 id="handler对象的方法"><a href="#handler对象的方法" class="headerlink" title="handler对象的方法"></a>handler对象的方法</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get"><code>handler.get()</code></a>：属性读取操作的捕捉器。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/set"><code>handler.set()</code></a>：属性设置操作的捕捉器。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/deleteProperty"><code>handler.deleteProperty()</code></a>：<code>delete</code>操作符的捕捉器。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/apply"><code>handler.apply()</code></a>：函数调用的捕捉器。</li>
<li>等等</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>一个简单的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">    get(obj, prop)&#123;</span><br><span class="line">        <span class="keyword">return</span> prop <span class="keyword">in</span> obj ? obj[prop] : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.a = <span class="string">&#x27;haha&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.a) <span class="comment">// haha</span></span><br><span class="line"><span class="built_in">console</span>.log(p.b) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>通过代理，你可以轻松地验证向一个对象的传值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> validator = &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// The default behavior to store the value</span></span><br><span class="line">      obj[prop] = value;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// 表示成功</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">  p.age = <span class="string">&#x27;&#x27;</span> <span class="comment">// TypeError</span></span><br><span class="line">  p.age = <span class="number">300</span> <span class="comment">// RangeError</span></span><br><span class="line">  p.age = <span class="number">89</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="与Object-defineProperty的对比"><a href="#与Object-defineProperty的对比" class="headerlink" title="与Object.defineProperty的对比"></a>与<code>Object.defineProperty</code>的对比</h3><blockquote>
<p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
</blockquote>
<p>其实<code>defineProperty</code>也是一种代理对象，但<code>proxy</code>更为强大，实现的捕捉器更多。</p>
<p>此外，<code>proxy</code>对数组的捕获有更好地支持，比如<code>set</code>方法能够监听数组的<code>push</code>等赋值的方法。</p>
<h2 id="统一对象的操作API-Reflect"><a href="#统一对象的操作API-Reflect" class="headerlink" title="统一对象的操作API: Reflect"></a>统一对象的操作API: <code>Reflect</code></h2><blockquote>
<p><strong>Reflect</strong> 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与<a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler">proxy handlers</a>的方法相同。<code>Reflect</code>不是一个函数对象，因此它是不可构造的。</p>
</blockquote>
<p>当我们使用<code>Proxy</code>代理对象时，没有进行处理器对象<code>proxy.handles</code>的初始化也能正常使用代理对象，这是因为默认处理器对象中的方法默认都是<code>Reflect</code>提供的静态方法，此外，<code>Reflect</code>对象中还提供了一些对象的方法。具体参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">Reflect - MDN</a>。</p>
<p>可能你在使用中发现<code>Reflect</code>中的方法都可能有别的写法，比如下面一些常见的对象操作方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    hobbies: [],</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;hobbies&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> obj.hobbies) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以发现，既有操作符也有对象方法，使用起来比较混乱，我们可以使用<code>Reflect</code>中的方法来替代，会更具语义化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    hobbies: [],</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has(obj, <span class="string">&#x27;name&#x27;</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj)) <span class="comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;hobbies&#x27; ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.deleteProperty(obj, <span class="string">&#x27;hobbies&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。</p>
</blockquote>
<p><code>Promise</code>对象是ES6提出的一个用于解决传统异步编程回调函数嵌套过深等问题而设计的，<code>Promise</code>的内容比较多，本文不在此展开，而会在另一篇文章中详细介绍，你可以访问这里进行查看：<a href="">TODO</a></p>
<p>或者你可以浏览官方说明：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise - MDN</a>。</p>
<h2 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h2><blockquote>
<p>ECMAScript 2015 中引入的 JavaScript 类实质上是 JavaScript 现有的<strong>基于原型的继承的语法糖</strong>。类语法<strong>不会</strong>为JavaScript引入新的面向对象的继承模型。</p>
</blockquote>
<p>类<code>Class</code>实际上是个“特殊的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions">函数</a>”，就像你能够定义的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function">函数声明</a>一样，类语法有两个组成部分：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/class">类表达式</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/class">类声明</a>。</p>
<p>类的出现只是相较于原型链，能让我们更好地理解和处理面向对象的逻辑关系，本质还是一个函数。</p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><p>类的定义有两种方法，类似函数的定义，我们使用关键字<code>class</code>进行声明，或者使用类表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Jinx&#x27;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// Jinx</span></span><br></pre></td></tr></table></figure>

<p>类声明和类表达式的主体都执行在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>下。比如，构造函数，静态方法，原型方法，<code>getter</code>和<code>setter</code>都在严格模式下执行。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor">constructor</a>方法是一个特殊的方法，这种方法用于创建和初始化一个由<code>class</code>创建的对象。一个类只能拥有一个名为 “constructor”的特殊方法。如果类包含多个<code>constructor</code>的方法，则将抛出 一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"><code>SyntaxError</code></a> 。</p>
<p>一个构造函数可以使用 <code>super</code> 关键字来调用一个父类的构造函数。</p>
<h3 id="原型方法"><a href="#原型方法" class="headerlink" title="原型方法"></a>原型方法</h3><p>参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions">方法定义</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title">sign</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age &gt;= <span class="number">18</span> ? <span class="string">&#x27;adult&#x27;</span> : <span class="string">&#x27;child&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    selfIntroduction() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello, my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Jinx&#x27;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.sign); <span class="comment">// adult</span></span><br><span class="line"><span class="built_in">console</span>.log(p.selfIntroduction()); <span class="comment">// hello, my name is Jinx, I&#x27;m 22 years old.</span></span><br></pre></td></tr></table></figure>

<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>static</code> 关键字用来定义一个类的一个静态方法。调用静态方法不需要<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#The_object_(class_instance)">实例化</a>该类，但不能通过一个类实例调用静态方法。静态方法通常用于为一个应用程序创建工具函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> run() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;running....&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(p.run()); // TypeError: p.run is not a function</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.run()) <span class="comment">// running...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态方法不需要实例化就能调用，实例化之后反而不能调用是因为，静态方法是直接绑定在类（或者说函数）上面的，而普通方法都在原型链上。</p>
</blockquote>
<h3 id="共有字段和私有字段（实验阶段功能）"><a href="#共有字段和私有字段（实验阶段功能）" class="headerlink" title="共有字段和私有字段（实验阶段功能）"></a>共有字段和私有字段（实验阶段功能）</h3><blockquote>
<p>公共和私有字段声明是JavaScript标准委员会<a href="https://tc39.es/">TC39</a>提出的<a href="https://github.com/tc39/proposal-class-fields">实验性功能（第3阶段）</a>。浏览器中的支持是有限的，但是可以通过<a href="https://babeljs.io/">Babel</a>等系统构建后使用此功能。</p>
</blockquote>
<p>上面的声明可以写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    name = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 共有字段</span></span><br><span class="line">    #age = 0; // 私有字段</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>私有字段特殊在于，只能在类内部使用，其子类是不能访问这些私有字段的，具体如何实现可参考下一章节。</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在类声明时使用关键字<code>extends</code>可以继承一个类。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age, classNumber) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.classNumber = classNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Jinx&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;20200910&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.classNumber);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，如果子类中定义了构造函数，那么它必须先调用 <code>super()</code> 才能使用 <code>this</code> 。</p>
<p>除了继承一般类，也可以继承传统的基于函数的“类”。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age, classNumber) &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">        <span class="built_in">this</span>.classNumber = classNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.say() + <span class="string">`My classNumber is <span class="subst">$&#123;<span class="built_in">this</span>.classNumber&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Jinx&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;20200910&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.say());</span><br></pre></td></tr></table></figure>

<p>但类<strong>不能继承常规对象（不可构造的）</strong>。如果要继承常规对象，可以改用 <code>Reflect.setPrototypeOf()</code> 或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a>(可设置对象的原型（即内部的 <code>[[Prototype]]</code> 属性）为另一个对象或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a>，如果操作成功返回 <code>true</code>，否则返回 <code>false</code>。)</p>
<blockquote>
<p><strong>警告</strong>：由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 <code>[[Prototype]]</code>在**<em>各个**</em>浏览器和 JavaScript 引擎上都是一个很慢的操作。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    age: <span class="number">0</span>,</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="string">`I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age, classNumber) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.classNumber = classNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`I am <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, I am <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.My classNumber is <span class="subst">$&#123;<span class="built_in">this</span>.classNumber&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Reflect</span>.setPrototypeOf(Student.prototype, Person); <span class="comment">// 没有原型方法的对象，只能通过这种方式&quot;继承&quot;，不推荐使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Jinx&#x27;</span>, <span class="number">17</span>, <span class="string">&#x27;20200910&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.say());</span><br></pre></td></tr></table></figure>

<h3 id="派生类Species"><a href="#派生类Species" class="headerlink" title="派生类Species"></a>派生类Species</h3><p>你可能希望在派生数组类 <em><code>MyArray</code></em> 中返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a>对象。这种 species 方式允许你覆盖默认的构造函数。</p>
<p>例如，当使用像<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><code>map()</code></a>返回<strong>默认构造函数</strong>的方法时，您希望这些方法返回一个父<code>Array</code>对象，而不是<code>MyArray</code>对象。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/species"><code>Symbol.species</code></a> 符号可以让你这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Overwrite species to the parent Array constructor</span></span><br><span class="line">    <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">var</span> mapped = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> MyArray); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> MyArray); <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">console</span>.log(mapped <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="多继承Mix-ins"><a href="#多继承Mix-ins" class="headerlink" title="多继承Mix-ins"></a>多继承Mix-ins</h3><p>请参考另一篇文章：<a href="...">Javascript中的多继承与混合类Mixin</a></p>
<h2 id="利用ES5语法实现ES6的类Class"><a href="#利用ES5语法实现ES6的类Class" class="headerlink" title="利用ES5语法实现ES6的类Class"></a>利用ES5语法实现ES6的类Class</h2><p>为了更好地理解类的实现原理，我们尝试使用<code>ES5</code>的语法进行实现。</p>
<h3 id="类声明的实现"><a href="#类声明的实现" class="headerlink" title="类声明的实现"></a>类声明的实现</h3><p>首先是实现<strong>类的定义</strong>，类的本质还是一个函数，所以定义类就是在定义一个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, age)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =====&gt; es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候为了保证<code>Person</code>类能正常创建实例，我们可以加上这样的检测函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 检查实例与类是否符合规范</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 无法创建改函数(类)的实例</span></span><br><span class="line">    <span class="keyword">if</span>(!_instanceOf(instance, Constructor))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Cannot call a class as a function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 判断对象是否为某个类的实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceOf</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Constructor &amp;&amp; <span class="built_in">Symbol</span> &amp;&amp; Constructor[<span class="built_in">Symbol</span>.hasInstance]) &#123;</span><br><span class="line">        <span class="keyword">return</span> !!Constructor[<span class="built_in">Symbol</span>.hasInstance](instance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance <span class="keyword">instanceof</span> Constructor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="built_in">this</span>, Person);</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>Constructor[Symbol.hasInstance](obj)</code>用于判断某对象是否为某构造器的实例。</li>
<li>在函数的定义中，函数名本身就相当于构造器本身，而<code>this</code>指向该类的实例，本质上就是一个对象。</li>
</ul>
</blockquote>
<h3 id="原型方法的实现"><a href="#原型方法的实现" class="headerlink" title="原型方法的实现"></a>原型方法的实现</h3><p>原型方法顾名思义，就是绑定在原型链上的函数，比如新增一个原型方法<code>say</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="built_in">this</span>, Person);</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">`hello, My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">&#x27;Jinx&#x27;</span>, <span class="number">23</span>).say(); <span class="comment">// hello, My name is Jinx, I&#x27;m 23 years old.</span></span><br></pre></td></tr></table></figure>

<p>为了写得更严谨一些，我们可以使用<strong>代理对象</strong>（ES6可以用<code>Proxy</code>，这里是ES5版本，所以我们还是使用<code>Object.defineProperty</code>）来实现原型链的函数绑定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用代理对象绑定属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_defineProperties</span>(<span class="params">obj, props</span>) </span>&#123;</span><br><span class="line">    props &amp;&amp; props.forEach(<span class="function"><span class="params">prop</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(obj, prop.key, &#123;</span><br><span class="line">            configurable: !!prop.configurable,</span><br><span class="line">            enumerable: !!prop.enumerable,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            value: prop.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="built_in">this</span>, Person);</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="comment">// 原型函数的绑定</span></span><br><span class="line">    _defineProperties(Person.prototype, [&#123;</span><br><span class="line">        key: <span class="string">&#x27;say&#x27;</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;hello, My name is &#x27;</span>.concat(<span class="built_in">this</span>.name, <span class="string">&quot;, I&#x27;m &quot;</span>, <span class="built_in">this</span>.age, <span class="string">&#x27; years old.&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态方法的实现"><a href="#静态方法的实现" class="headerlink" title="静态方法的实现"></a>静态方法的实现</h3><p>静态方法与原型方法的不同之处就在于，静态方法是直接绑定在<code>构造器</code>上的，所以直接不用实例就能调用，比如我们把<code>say</code>方法改为今天方法，只需要修改代理对象的即可：（Person.prototype -&gt; Person）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="built_in">this</span>, Person);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态函数</span></span><br><span class="line">    _defineProperties(Person, [&#123;</span><br><span class="line">        key: <span class="string">&#x27;say&#x27;</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;hello, My name is &#x27;</span>.concat(<span class="built_in">this</span>.name, <span class="string">&quot;, I&#x27;m &quot;</span>, <span class="built_in">this</span>.age, <span class="string">&#x27; years old.&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们发现，这里使用了类表达式来申明，这是因为静态函数不需要创建实例就能使用，所以我们在申明函数时就需要绑定好静态方法与构造函数之间的关系。</p>
</blockquote>
<h3 id="字段的绑定"><a href="#字段的绑定" class="headerlink" title="字段的绑定"></a>字段的绑定</h3><blockquote>
<p>属性也就是同方法的绑定没有太大区别，一般属性绑定在实例对象上，而静态属性直接绑定在构造函数上。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 字段(属性)</span></span><br><span class="line">    Person.prototype.age = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    Person.flag = <span class="string">&#x27;person class&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;Jinx&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// &#x27;Jinx&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(p.flag) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.flag) <span class="comment">// person class</span></span><br></pre></td></tr></table></figure>

<h3 id="继承的实现"><a href="#继承的实现" class="headerlink" title="继承的实现"></a>继承的实现</h3><blockquote>
<p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 <strong>proto</strong> ）指向它的构造函数的原型对象（<strong>prototype</strong> ）。该原型对象也有一个自己的原型对象( <strong>proto</strong> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p>
<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a> 的实例。</p>
</blockquote>
<p>由于篇幅过长，会另外开启一篇文章进行梳理，可以参考这里<a href="">TODO</a>。</p>
<p>此外，我们也可以使用下面的地址将<code>ES6</code>代码转化为<code>ES5</code>代码，方便我们对比各个版本之间的写法：</p>
<ul>
<li><a href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYGwhgzhAEAKCmAnCB7AdtA3gKGtbAvkA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=false&timeTravel=false&sourceType=module&lineWrap=false&presets=es2015%2Creact%2Cstage-2&prettier=false&targets=&version=7.11.6&externalPlugins=">Babel - JS转换</a>。</li>
<li><a href="https://google.github.io/traceur-compiler/demo/repl.html#">Traceur</a>。</li>
</ul>
<h2 id="集合Set对象"><a href="#集合Set对象" class="headerlink" title="集合Set对象"></a>集合Set对象</h2><blockquote>
<p><code>Set</code>对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会<strong>出现一次</strong>，即 Set 中的元素是唯一的。</p>
</blockquote>
<p>你可以把<code>Set</code>理解为没有重复元素的数组。语法如下：</p>
<blockquote>
<p><strong>new Set([iterable])</strong></p>
<p>你可以传入一个可迭代对象<code>iterable</code>作为参数，这样，集合就能接手并不重复地把迭代对象中的元素加入到集合实例中。</p>
</blockquote>
<p>集合<code>Set</code>的<code>api</code>和数组类似，比如常用的一些<code>api</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例属性 size :表示集合长度(元素个数)</span></span><br><span class="line"><span class="built_in">console</span>.log(s.size); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [添加]一个元素，返回实例本身，所以你可以链式调用</span></span><br><span class="line"><span class="built_in">console</span>.log(s.add(<span class="number">4</span>).add(<span class="number">5</span>)); <span class="comment">// Set &#123; 1, 2, 3, 4, 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [删除]一个元素，成功则返回true，否则返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(s.delete(<span class="number">3</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [清空]所有元素,无返回值</span></span><br><span class="line"><span class="built_in">console</span>.log(s.clear()) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [has]判断元素是否存在集合中</span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">0</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个新的【迭代器对象】，这个对象的元素是类似 [value, value] 形式的数组，即IterableIterator&lt;[number, number]&gt;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> ent <span class="keyword">of</span> s.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ 1, 1 ]</span></span><br><span class="line"><span class="comment">// [ 2, 2 ]</span></span><br><span class="line"><span class="comment">// [ 3, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个新的【迭代器对象】,与entries不同在于，values | keys 方法只返回集合中元素的迭代对象（由于键和值一样，这两个方法也无区别）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ent <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 【forEach】遍历集合</span></span><br><span class="line">s.forEach(<span class="function">(<span class="params">key, val, set</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="string">&#x27;-&#x27;</span>, val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 1 - 1</span></span><br><span class="line"><span class="comment">// 2 - 2</span></span><br><span class="line"><span class="comment">// 3 - 3</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<code>for of</code>循环也是<code>ES6</code>提出的一种新循环语句，只要实现可迭代接口，就<strong>能遍历任意数据类型</strong>。详细请参考后文。</p>
</blockquote>
<h2 id="映射集合Map对象"><a href="#映射集合Map对象" class="headerlink" title="映射集合Map对象"></a>映射集合Map对象</h2><blockquote>
<p><strong><code>Map</code></strong> 对象保存键值对，并且能够记住键的原始插入顺序。<strong>任何值</strong>(对象或者<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">原始值</a>) 都可以作为一个键或一个值。</p>
</blockquote>
<p>说到键值对对象，我们很容易想到<code>js</code>最普遍的<code>Object</code>对象就是一种键值对对象，那为什么还需要<code>Map</code>呢？我们先看一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    <span class="literal">true</span>: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">1</span>,</span><br><span class="line">    [<span class="literal">undefined</span>]: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// [ &#x27;1&#x27;, &#x27;name&#x27;, &#x27;true&#x27;, &#x27;undefined&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>可以发现，<code>Object</code>这种映射只是<code>字符串 - 数据</code>的映射，不管我们传入什么值作为键，都会被转为字符串或者<code>Symbol</code>（ES6新增的一种数据类型，见后文）。</p>
<p>但<code>Map</code>是真正的数据之间的映射，<code>Map</code>的之间的键可能是任意类型的对象（数据）,语法如下：</p>
<blockquote>
<p><strong>new Map([iterable])</strong></p>
<p>Iterable 可以是一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>数组</code></a>或者其他 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/iterable">iterable</a> 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。<code>null</code> 会被当做 <code>undefined。</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> say = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Jinx&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;age&#x27;</span>, <span class="number">22</span>],</span><br><span class="line">    [say, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;say something&#x27;</span>;</span><br><span class="line">    &#125;],</span><br><span class="line">])</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; &#x27;name&#x27; =&gt; &#x27;Jinx&#x27;, &#x27;age&#x27; =&gt; 22, 11 =&gt; [Function] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.get(say)()); <span class="comment">// say something</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of"><code>for...of</code></a> 循环在每次迭代后会返回一个形式为[key，value]的数组。</p>
</blockquote>
<p>一些基本的<code>api</code>，和<code>Set</code>很类似：</p>
<ul>
<li>clear()：清空集合。</li>
<li>delete(key)：按照键删除该映射关系，成功则返回true。</li>
<li>entries()：返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了Map对象中每个元素的 <strong><code>[key, value]</code></strong> <code>数组</code>。</li>
<li>forEach()：按插入顺序，为 <code>Map</code>对象里的每一键值对调用一次callbackFn函数。</li>
<li>get(key)：根据映射关系的键返回对应的值。</li>
<li>set(key, value)：设置Map对象中键的值。返回该Map对象。</li>
<li>has(key)：判断该键是否存在对应的映射关系，注意只要设置了映射关系，就算值为<code>undefined</code>也返回true。</li>
<li>keys()：按插入顺序返回集合键的<code>Iterator</code>对象。</li>
<li>values()：按插入顺序返回集合值的<code>Iterator</code>对象。</li>
</ul>
<p>总结一下<code>Map</code>和<code>Object</code>的<strong>区别</strong>：</p>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="left">Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td align="left">意外的键</td>
<td align="left"><code>Map</code> 默认情况不包含任何键。只包含显式插入的键。</td>
<td>一个 <code>Object</code> 有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。<strong>注意:</strong> 虽然 ES5 开始可以用 <code>Object.create(null)</code> 来创建一个没有原型的对象，但是这种用法不太常见。</td>
</tr>
<tr>
<td align="left">键的类型</td>
<td align="left">一个 <code>Map</code>的键可以是<strong>任意值</strong>，包括函数、对象或任意基本类型。</td>
<td>一个<code>Object</code> 的键必须是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a> 或是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>。</td>
</tr>
<tr>
<td align="left">键的顺序</td>
<td align="left"><code>Map</code> 中的 key 是有序的。因此，当迭代的时候，一个 <code>Map</code> 对象以插入的顺序返回键值。</td>
<td>一个 <code>Object</code> 的键是无序的注意：自ECMAScript 2015规范以来，对象<em>确实</em>保留了字符串和Symbol键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。</td>
</tr>
<tr>
<td align="left">Size</td>
<td align="left"><code>Map</code> 的键值对个数可以轻易地通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size"><code>size</code></a> 属性获取</td>
<td><code>Object</code> 的键值对个数只能手动计算</td>
</tr>
<tr>
<td align="left">迭代</td>
<td align="left"><code>Map</code> 是 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable">iterable</a> 的，所以可以直接被迭代。</td>
<td>迭代一个<code>Object</code>需要以某种方式获取它的键然后才能迭代。</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">在频繁增删键值对的场景下表现更好。</td>
<td>在频繁添加和删除键值对的场景下未作出优化。</td>
</tr>
</tbody></table>
<h2 id="新数据类型Symbol"><a href="#新数据类型Symbol" class="headerlink" title="新数据类型Symbol"></a>新数据类型Symbol</h2><blockquote>
<p>新增的一种<strong>原始数据类型</strong>，读作“<strong>符号</strong>”。该类型的性质在于这个类型的值可以用来创建<strong>匿名的对象属性</strong>。</p>
<p><strong>symbol</strong> 数据类型具有非常明确的目的，并且因为其功能性单一的优点而突出；一个 <strong>symbol</strong> 实例可以被赋值到一个左值变量，还可以通过标识符检查类型，这就是它的全部特性。</p>
<p>【目的】唯一性：在 JavaScript 运行时环境中，一个符号类型值可以通过调用函数 <code>Symbol()</code> 创建，这个函数动态地生成了一个匿名，<strong>唯一的值</strong>。</p>
<p>【特点】匿名性：当一个 symbol 类型的值在属性赋值语句中被用作标识符，该属性（像这个 symbol 一样）是匿名的；并且是<strong>不可枚举</strong>的。它同样不会出现在 “<code>Object.getOwnPropertyNames()</code>” 的返回数组里。这个属性可以通过创建时的原始 symbol 值访问到，或者通过遍历 “<code>Object.getOwnPropertySymbols()</code>” 返回的数组。</p>
</blockquote>
<p><strong>Symbol</strong> 类具有一些静态属性，对于匿名命名来说，这带有一点讽刺意味。这类属性只有几个; 它们是所谓的“众所周知”的 symbol。 它们是在某些内置对象中找到的某些特定方法属性的 symbol。 暴露出这些 symbol 使得可以直接访问这些行为；这样的访问可能是有用的，例如在定义自定义类的时候。 普遍的 symbol 的例子有：“<code>Symbol.iterator</code>”用于类似数组的对象，“<code>Symbol.search</code>”用于字符串对象。</p>
<p><code>Symbol()</code>函数及其创建的 symbol 值可能对设计自定义类的编程人员有用。 symbol 值提供了一种自定义类可以<strong>创建私有成员</strong>的方式（匿名，所以不能被继承下去），并维护一个仅适用于该类的 symbol 注册表。 在类定义中，动态创建的 symbol 值将保存到作用域变量中，该变量只能在类定义中私有地使用。 没有 token 字符串; 作用域变量起到 token 的等同作用。</p>
<p>举个简单的例子，文章前文对比过<code>Object</code>和<code>Map</code>区别，其中一点就是<code>Object</code>常常会造成不确定的键导致<strong>数据覆盖</strong>。比如：</p>
<p><code>main.js</code>向外暴露出一个<code>obj</code>对象，但其他模块是不知道该对象有哪些键的，如果使用到了相同的键就会发生不必要的意外，一般的做法是约定自己内部使用的键，加上特殊的标记，比如<code>b.js</code>的做法：加上特殊前缀：<code>b_</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- main.js</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- a.js</span></span><br><span class="line">obj.name = <span class="string">&#x27;Tom&#x27;</span> <span class="comment">// 发生覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- b.js</span></span><br><span class="line">obj.b_name = <span class="string">&#x27;Yasuo&#x27;</span> <span class="comment">// 做一个约定，避免覆盖</span></span><br></pre></td></tr></table></figure>

<p>但<code>symbol</code>的出现很好地解决了这一问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --- main.js</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    age: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- a.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="built_in">Symbol</span>();</span><br><span class="line">obj[name] = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&#x27;name&#x27;</span>]); <span class="comment">// Jinx</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[name]); <span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>()]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="for-of循环语句"><a href="#for-of循环语句" class="headerlink" title="for...of循环语句"></a><code>for...of</code>循环语句</h2><p><code>for...of</code>语句是一种新的循环语句，更好地说法叫迭代器，能遍历可迭代对象的所有元素，理论上可以遍历所有类型的对象，只要<strong>实现了可迭代接口</strong>(详情见后文)。基本语法如下：</p>
<blockquote>
<p>for (variable of iterable) {<br>    //statements<br>}</p>
<ul>
<li>variable：在每次迭代中，将不同属性的值分配给变量。</li>
<li>iterable：被迭代枚举其属性的对象。</li>
</ul>
</blockquote>
<p>比如数组的迭代，我们常常使用<code>forEach</code>来进行操作，但该函数由于是回调函数操作，无法结束循环，所以我们可以换成<code>for...of</code>来遍历数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> val <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span>(val &gt; <span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>此外，我们还可以迭代一些常见的数据对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----迭代字符串----&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c) <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">in</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c) <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----迭代Set----&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> set)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s); <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">in</span> set)&#123; <span class="comment">// 无法枚举，不报错，但不会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----迭代Map----&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [k,v] <span class="keyword">of</span> map)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k, <span class="string">&#x27;-&#x27;</span> , v); <span class="comment">// 1 - a 2 - b 3 - c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">in</span> map)&#123; <span class="comment">// 无法枚举，不报错，但不会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;----迭代Dom集合----&#x27;</span>)</span><br><span class="line"><span class="comment">//注意：这只能在实现了NodeList.prototype[Symbol.iterator]的平台上运行</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;article &gt; p&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> paragraph <span class="keyword">of</span> articleParagraphs) &#123;</span><br><span class="line">    paragraph.classList.add(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>for...of</code>的循环，可以由<code>break</code>, <code>throw continue </code>  或<code>return</code>终止。在这些情况下，迭代器关闭。</p>
<p>我们可以发现，<code>for...of</code>可以迭代很多内置对象的实例，包括<code>for in</code>无法枚举的<code>Set</code>，<code>Map</code>这些对象，实际上：</p>
<ul>
<li><code>for in</code>语句以任意顺序迭代对象的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举属性</a>。</li>
<li><code>for...of</code> 语句遍历<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterables">可迭代对象</a>定义要迭代的数据。</li>
</ul>
<p>所以，<code>for...in</code>能迭代的是具有可枚举属性的对象，然后再根据属性来获取对象的值，而<code>for...of</code>能迭代一切实现了可迭代接口的对象，我们能直接迭代数组这些内置对象，是因为这些对象的意见内置实现了可迭代接口。</p>
<p>可能你已经发现了，我们常常使用到的<code>Object</code>对象反而无法进行迭代，如果我们需要我们的自定义对象能够迭代，还需要我们<strong>自行实现可迭代接口</strong>，请直接阅读下一章节。</p>
<h2 id="可迭代接口"><a href="#可迭代接口" class="headerlink" title="可迭代接口"></a>可迭代接口</h2><blockquote>
<p>可迭代接口或者说<strong>可迭代协议</strong>，允许 JavaScript 对象定义或定制它们的迭代行为，例如，在一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of"><code>for..of</code></a> 结构中，哪些值可以被遍历到。一些内置类型同时是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E5%86%85%E7%BD%AE%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1">内置可迭代对象</a>，并且有默认的迭代行为，比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Map"><code>Map</code></a>，而其他内置类型则不是（比如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a>)）。</p>
</blockquote>
<p>要成为<strong>可迭代</strong>对象， 一个对象必须实现 <code>**@@iterator**</code> 方法。这意味着对象（或者它<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">原型链</a>上的某个对象）必须有一个键为 <code>@@iterator</code> 的属性，可通过常量 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator"><code>Symbol.iterator</code></a> 访问该属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>[Symbol.iterator]</code></td>
<td align="left">返回一个符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%8D%8F%E8%AE%AE">迭代器协议</a>的对象的无参数函数。</td>
</tr>
</tbody></table>
<p>注：此函数可以是<strong>普通函数</strong>，也可以是生成器函数，以便在调用时返回迭代器对象。 在此生成器函数的内部，可以使用<code>yield</code>提供每个条目。（生成器函数详情可参考下一章节）</p>
<h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>只有实现了一个拥有以下语义（semantic）的 <code>next()</code> 方法，一个对象才能成为迭代器：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>next</code></td>
<td align="left">一个无参数函数，返回一个应当拥有以下两个属性的对象：<code>done</code>（boolean）如果迭代器可以产生序列中的下一个值，则为 <code>false</code>。（这等价于没有指定 <code>done</code> 这个属性。）如果迭代器已将序列迭代完毕，则为 <code>true</code>。这种情况下，<code>value</code> 是可选的，如果它依然存在，即为迭代结束之后的默认返回值。<code>value</code>迭代器返回的任何 JavaScript 值。done 为 true 时可省略。<code>next()</code> 方法必须返回一个对象，该对象应当有两个属性： <code>done</code> 和 <code>value</code>，如果返回了一个非对象值（比如 <code>false</code> 或 <code>undefined</code>），则会抛出一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a> 异常（<code>&quot;iterator.next() returned a non-object value&quot;</code>）。</td>
</tr>
</tbody></table>
<p>总结来说就是，实现迭代器接口就是，需要实现一个<code>[Symbol.iterator]</code>函数，该函数必须实现了<code>next</code>函数，该<code>netx</code>函数必须返回具有<code>done</code>和<code>value</code>属性的对象。</p>
<p>可能描述有点长，我们来简单实现一下就明了了，假设有这么一个对象需要我们使用<code>for...of</code>进行迭代，我们希望能使用迭代器返回对应的<code>name</code>和<code>age</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    names: [<span class="string">&#x27;Jinx&#x27;</span>, <span class="string">&#x27;Yasuo&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>],</span><br><span class="line">    ages: [<span class="number">22</span>, <span class="number">23</span>, <span class="number">4</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接使用迭代器是会报错的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> o <span class="keyword">of</span> obj) &#123; <span class="comment">// TypeError: obj is not iterable</span></span><br><span class="line">    <span class="built_in">console</span>.log(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一步</strong>：实现迭代器函数<code>[Symbol.iterator]</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    names: [<span class="string">&#x27;Jinx&#x27;</span>, <span class="string">&#x27;Yasuo&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>],</span><br><span class="line">    ages: [<span class="number">22</span>, <span class="number">23</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;....&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>：该函数需要实现一个<code>next</code>函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    names: [<span class="string">&#x27;Jinx&#x27;</span>, <span class="string">&#x27;Yasuo&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>],</span><br><span class="line">    ages: [<span class="number">22</span>, <span class="number">23</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;next...&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>：<code>next</code>函数必须返回具有<code>done</code>和<code>value</code>属性的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    names: [<span class="string">&#x27;Jinx&#x27;</span>, <span class="string">&#x27;Yasuo&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>],</span><br><span class="line">    ages: [<span class="number">22</span>, <span class="number">23</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">const</span> len = <span class="built_in">Math</span>.min(self.names.length, self.ages.length);</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    done: index++ &gt;= len - <span class="number">1</span>, <span class="comment">// 结束标记</span></span><br><span class="line">                    value: [self.names[index], self.ages[index]], <span class="comment">// 每次迭代的返回值</span></span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就能使用迭代语句进行遍历了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> o <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ &#x27;Jinx&#x27;, 22 ]</span></span><br><span class="line"><span class="comment">// [ &#x27;Yasuo&#x27;, 23 ]</span></span><br><span class="line"><span class="comment">// [ &#x27;Cat&#x27;, 4 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="为何要实现可迭代接口"><a href="#为何要实现可迭代接口" class="headerlink" title="为何要实现可迭代接口"></a>为何要实现可迭代接口</h3><p>在上面的使用场景中，我们不需要实现迭代器接口也能实现对应的功能，但由于模块化的开发越来越普遍，可能这个自定义对象是别人给的，或者说是需要给别人的，也就是<strong>不同的人在维护</strong>，假设你没有实现可迭代接口，那么使用的人就需要自己遍历数据，但是对象数据是可能发生变更的，比如上面的<code>obj</code>又新增了一个<code>skills</code>字段需要遍历，那么每个使用到这个对象的人都需要修改自己的遍历器，这是比较麻烦的。</p>
<p>但是实现了可迭代接口，每个使用到的人只需要使用相同的<code>for...of</code>这样的迭代语句就能拿到迭代器设计好的数据，也就是<strong>对外暴露统一的迭代方法</strong>，而无需让使用者担心数据变化带来困扰。</p>
<blockquote>
<p>可以发现，迭代语句<code>for...of</code>完全可以使用普通的<code>for</code>或者<code>while</code>等实现，但这相当于一种设计思想，<strong>实现统一的接口</strong>能为我们解决很多应用场景上的麻烦和带来使用上的便利。</p>
</blockquote>
<h2 id="生成器Generator"><a href="#生成器Generator" class="headerlink" title="生成器Generator"></a>生成器<code>Generator</code></h2><blockquote>
<p><strong>生成器</strong>对象是由一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*">generator function</a> 返回的,并且它符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterable">可迭代协议</a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#iterator">迭代器协议</a>。</p>
</blockquote>
<p>单词<code>generator</code>为“发电机”的意思，生成器也是这个道理，生成器函数能<strong>源源不断</strong>的提供数据，直到<code>return</code>结束。</p>
<h3 id="定义一个生成器函数"><a href="#定义一个生成器函数" class="headerlink" title="定义一个生成器函数"></a>定义一个生成器函数</h3><p>生成器函数的语法十分简单，只需要把普通函数的声明关键字<code>function</code>变成<code>function*</code>或<code>function *</code>即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;this is a generator.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo()) <span class="comment">// Object [Generator] &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们打印发现，函数返回了一个生成器对象，并非<code>return</code>语句后的结果。上面我们说到，生成器对象实现了可迭代协议，所以我们需要使用<code>next</code>函数取出数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo().next()) <span class="comment">// &#123; value: 100, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h3><p>当然，如果只是这样的迭代器效果，就不能体现生成器的特点了，一般迭代器需要和<code>yield</code>关键字搭配使用。<code>yield</code>关键字使生成器函数<strong>执行暂停</strong>，<code>yield</code>关键字后面的表达式的值返回给生成器的调用者。它可以被认为是一个基于生成器的版本的<code>return</code>关键字。</p>
<p>我们改造一下上面的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">    <span class="keyword">yield</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gnr_foo = foo();</span><br><span class="line"><span class="built_in">console</span>.log(gnr_foo.next()) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gnr_foo.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gnr_foo.next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gnr_foo.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>虽然函数体没有写<code>retrun</code>语句，但和普通函数一样，有一个默认的<code>return undefined</code>。</p>
</blockquote>
<h3 id="生成器的应用"><a href="#生成器的应用" class="headerlink" title="生成器的应用"></a>生成器的应用</h3><p>生成器的特点就是能<strong>让函数分步执行（暂停执行）</strong>，我们可以利用这个特点实现一个<strong>发号器</strong>，比如你到银行排队区号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发号器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">IdNumberGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> idGenerator = IdNumberGenerator();</span><br><span class="line"><span class="built_in">console</span>.log(idGenerator.next().value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(idGenerator.next().value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(idGenerator.next().value) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>当使用者获取号码时就相当于调用一次生成器的<code>next</code>方法。</p>
<p>此外，生成器还可以解决异步编程的回调函数嵌套过深的问题，这部分内容将会和<code>Promise</code>对象进行统一梳理，感兴趣的可以参考这里进行查看：<a href="">TODO</a>。</p>
<h2 id="模块化Modules"><a href="#模块化Modules" class="headerlink" title="模块化Modules"></a>模块化Modules</h2><blockquote>
<p>模块化Modules属于语言层面的模块化标准。</p>
</blockquote>
<p>早期的<code>javascript</code>作为页面脚本语言是很小的，作为了实现简单的交互效果，但随着<code>web</code>的发展，<code>js</code>代码逐渐变得复杂，代码之间的交互也变得频繁，相互调用的情况愈来愈多，模块化开发是大势所趋。</p>
<p>由于篇幅过长，这里不再展开叙述，感兴趣的可以参考官网的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">模块化Modules</a>。</p>
<h2 id="ES2016新特性"><a href="#ES2016新特性" class="headerlink" title="ES2016新特性"></a>ES2016新特性</h2><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>该方法是新增的一个数组原型方法，用于判断数组是否包含某个元素，我们之前的做法是使用<code>indexOf</code>方法来获取元素对应的下标来判断元素是否存在，但这里还是有有一些区别：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="literal">NaN</span>, <span class="number">-0</span>, <span class="literal">false</span>, <span class="literal">null</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="literal">NaN</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">-0</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="number">-0</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="number">0</span>, <span class="number">-0</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符**"></a>指数运算符<code>**</code></h3><p>以前我们实现指数运算需要借助<code>Math.pow</code>函数，现在可以直接使用<code>**</code>运算符了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>) == <span class="number">2</span> ** <span class="number">3</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="ES2017新特性"><a href="#ES2017新特性" class="headerlink" title="ES2017新特性"></a>ES2017新特性</h2><p><code>ES2017</code>新增了<code>Object</code>对象的三个扩展方法，新增字符串的两个原型方法，以及一些小特性。</p>
<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values"></a>Object.values</h3><blockquote>
<p><code>**Object.values()**</code>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a>循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Chiang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)) <span class="comment">// [ &#x27;Jinx&#x27;, &#x27;Chiang&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>也就是对应<code>Object.keys</code>方法用来获取<code>key</code>一样。</p>
<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h3><p>同<code>Object.values</code>一样，如果想要同时获得键和值的迭代对象，就可以使用<code>entries</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Chiang&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)) <span class="comment">// [ [ &#x27;firstName&#x27;, &#x27;Jinx&#x27; ], [ &#x27;lastName&#x27;, &#x27;Chiang&#x27; ] ]</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h3><p>上文有说过<code>Object.assign</code>方法，可以用于复制多个对象并组合为一个新的对象，但只能<strong>浅复制</strong>，比如对象上的<code>geter</code>和<code>setter</code>就无法正常复制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Chiang&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName); <span class="comment">// Jinx Chiang</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line">obj2.firstName = <span class="string">&#x27;Yasuo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName); <span class="comment">// Jinx Chiang</span></span><br><span class="line"></span><br><span class="line">obj.firstName = <span class="string">&#x27;Dongoog&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.fullName); <span class="comment">// Dongoog Chiang</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName); <span class="comment">// Jinx Chiang</span></span><br></pre></td></tr></table></figure>

<p>这是因为<code>Object.assign</code>复制时只是把<code>fullName</code>当成普通的属性进行复制了，并没有复制为真正的<code>getter</code>。</p>
<p>我们通过<code>Object.getOwnPropertyDescriptors</code>就可以拿到这些真正的描述信息，从而进行复制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Chiang&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProps = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="built_in">console</span>.log(objProps);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     firstName: &#123;</span></span><br><span class="line"><span class="comment">//         value: &#x27;Jinx&#x27;,</span></span><br><span class="line"><span class="comment">//         writable: true,</span></span><br><span class="line"><span class="comment">//         enumerable: true,</span></span><br><span class="line"><span class="comment">//         configurable: true</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     lastName: &#123;</span></span><br><span class="line"><span class="comment">//         value: &#x27;Chiang&#x27;,</span></span><br><span class="line"><span class="comment">//         writable: true,</span></span><br><span class="line"><span class="comment">//         enumerable: true,</span></span><br><span class="line"><span class="comment">//         configurable: true</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     fullName: &#123;</span></span><br><span class="line"><span class="comment">//         get: [Function: get fullName],</span></span><br><span class="line"><span class="comment">//         set: undefined,</span></span><br><span class="line"><span class="comment">//         enumerable: true,</span></span><br><span class="line"><span class="comment">//         configurable: true</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Jinx&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Chiang&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProps = <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj);</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.defineProperties(&#123;&#125;, objProps);</span><br><span class="line">obj2.firstName = <span class="string">&#x27;Yasuo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj2.fullName); <span class="comment">// Yasuo Chiang</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Object.defineProperties进行的也还是浅拷贝，要实现对象的深拷贝一般需要进行对象遍历再逐一赋值。</p>
</blockquote>
<h3 id="String-prototype-padStart-amp-String-prototype-padEnd"><a href="#String-prototype-padStart-amp-String-prototype-padEnd" class="headerlink" title="String.prototype.padStart &amp; String.prototype.padEnd"></a>String.prototype.padStart &amp; String.prototype.padEnd</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/ECMAScript">ECMAScript-维基百科</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值-MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数-MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy-MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes">Classes-MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">原型链与继承-MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol">symbol-MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of">for…of-MDN</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">可迭代协议-MDN</a></li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化开发概述</title>
    <url>/2020/11/14/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>随着前端功能的日趋复杂，模块化开发变得尤为重要，在大型项目中，模块化的开发方式不仅能有效复用代码，还能针对性的修改模块代码而不影响项目的稳定运行，还能借助同样功能的第三方模块，提高开发效率。</p>
<p>模块化开发作为一种主流开发思想，开发项目就像搭积木一样，每一个模块就是一个个独立的积木而已。但是在代码中会相对复杂一些，模块之间的相互引用导致了模块并非完全独立于其他模块的。</p>
<p>本文主要就前端模块化开发的演变过程，重点说明<code>js</code>的模块化规范：浏览器端使用的<code>ES Modules</code>和Node环境使用的<code>CommonJS</code>规范。以及阐述如何通过基于模块化开发构建web应用。</p>
<p><img data-src="./images/modules.png"></p>
<a id="more"></a>

<h2 id="前端模块化开发的演变过程"><a href="#前端模块化开发的演变过程" class="headerlink" title="前端模块化开发的演变过程"></a>前端模块化开发的演变过程</h2><p>早期的模块化开发没有一个合理的规范，最开始的模块化就是把整个<code>js</code>文件拆分成若干个文件，可以理解为“<strong>文件划分</strong>”阶段。</p>
<p>比如某个项目下的<code>a.js</code>，<code>b.js</code>等等，在使用的时候简单的按照执行顺序引入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;a.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;b.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的方式除了按照功能划分了代码，并不是真正意义上的模块，代码之间仍然存在命名冲突，模块变量可以随意更改等问题。</p>
<p>总的来说，只是简单的做了文件划分的存在明显的缺陷：</p>
<ul>
<li>模块之间相互污染全局作用域</li>
<li>命名冲突</li>
<li>模块之间的引用关系无法管理</li>
</ul>
<p>除了方便根据文件名找到对应功能的代码，貌似没有别的好处。</p>
<p>为了尽量解决作用域污染和重名问题，我们使用命名空间来对变量进行空间限定，比如模块<code>a.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleA = &#123;</span><br><span class="line">    prop: &#123;&#125;,</span><br><span class="line">    name: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    method1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;method1 runing...&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    method2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;method2 runing...&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们在使用模块<code>a</code>的使用就不用担心内部成员被污染的情况，但是，模块内部的成员任然会被外部直接访问和修改到，没有做到私有化。</p>
<p>下一阶段可以称为<strong>立即执行阶段</strong>，即使用<code>IIFE</code>对模块代码进行闭包处理，这样，我们只需要导出我们希望导出的内容，而外部就不能再访问未暴露的变量，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;modeule a&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> props = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">method1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;method1 runing...&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">method2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;method2 runing...&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过绑定到全局作用局来导出模块</span></span><br><span class="line">    <span class="built_in">window</span>.moduleA = &#123;</span><br><span class="line">        props,</span><br><span class="line">        method1,</span><br><span class="line">        method2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(jQuery)</span><br></pre></td></tr></table></figure>

<p>立即执行函数能解决变量私有化的问题，大部分情况下已经解决了模块化开发的需求，但是这种写法也是多种多样的，对于别人的代码和模块，引用和修改起来还是十分不便，这样就需要一种规范化出现，让开发者们都遵循和使用这些规范进行开发，也就能解决上述问题。</p>
<p>模块化规范最主要的就是解决：模块引用和模块导出的问题。</p>
<p>其中，<a href="https://javascript.ruanyifeng.com/nodejs/module.html">commonJS规范</a>是出现较早的规范，目前也是被<code>Node</code>所使用的模块化规范。</p>
<p>CommonJS规范有以下约定：</p>
<ul>
<li>一个文件就是一个模块</li>
<li>每个模块都有单独的作用域</li>
<li>通过<code>module.exports</code>导出成员</li>
<li>通过<code>require</code>函数载入其他模块导出的成员</li>
</ul>
<p>CommonJS规范的模块加载是同步执行的，也就是模块加载完成后再执行代码，对于Node来说，主要应用于服务器开发，代码存储在本地，同步加载也比较快，所以执行起来没什么效率问题，但在浏览器端就不行了，如果执行一段代码需要不断地从服务器加载同步模块，会导致浏览器执行效率低下，因此，浏览器采用AMD这种异步加载模块的规范来实现模块化开发。<a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a>是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>AMD模块也是用<code>require</code>函数导入模块，但需要使用回调函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个模块</span></span><br><span class="line">define(<span class="string">&#x27;module1&#x27;</span>, [<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;./modules2&#x27;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$, modules2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            $(<span class="string">&#x27;#start&#x27;</span>).animate(&#123; <span class="attr">margin</span>: <span class="string">&#x27;280px&#x27;</span> &#125;);</span><br><span class="line">            modules2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块，并在回调函数中使用模块</span></span><br><span class="line"><span class="built_in">require</span>([module1 jquery], <span class="function"><span class="keyword">function</span>(<span class="params">module1, $</span>)</span>&#123;</span><br><span class="line">    module1.start();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>目前，主要有两个Javascript库实现了AMD规范：<a href="http://requirejs.org/">require.js</a>，<a href="https://github.com/cujojs/curl">curl.js</a>和<a href="https://github.com/seajs/seajs">seajs</a>。但使用起来还是很复杂，且模块较多时，模块js文件加载请求变得频繁，所以，AMD规范也只是浏览器端模块规范化的一步。</p>
<p>目前最佳的模块化规范就是：浏览器端的<code>ES Modules</code>和Node端的<code>CommonJS</code>规范，这两个规范都是内置的规范，不存在执行环境问题，需要注意的是<code>ES Modules</code>是<code>es6</code>才推出的模块化规范，所以早期的大部分浏览器都不支持<code>ES Modules</code>规范，这就需要我们注意在使用<code>ES Moduels</code>规范开发时的兼容问题。</p>
<h2 id="浏览器端的模块化规范：ES-Modules"><a href="#浏览器端的模块化规范：ES-Modules" class="headerlink" title="浏览器端的模块化规范：ES Modules"></a>浏览器端的模块化规范：ES Modules</h2><p>上文提到的CAD规范只是为了能实现浏览器端的模块化开发而做的“妥协”方法，执行效率上仍然是个问题。最终，在ES6，我们等到了原生模块化的支持 ： ES Modules — 浏览器能够最优化加载模块，使它比使用库更有效率：使用库通常需要做额外的客户端处理。</p>
<h3 id="导出模块成员"><a href="#导出模块成员" class="headerlink" title="导出模块成员"></a>导出模块成员</h3><p>使用<code>export</code>关键字在最外层对变量进行导出即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;jinx&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  nums.forEach(<span class="function"><span class="params">n</span> =&gt;</span> total += n);</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>export</code>只能写在最外层，而不能写到执行语句中。</p>
</blockquote>
<p>还有一种简单的方法是在最后统一导出成员：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;name, add&#125;</span><br></pre></td></tr></table></figure>

<p>为避免重名问题，我们还可以把</p>
<h3 id="导入模块和成员"><a href="#导入模块和成员" class="headerlink" title="导入模块和成员"></a>导入模块和成员</h3><p>你想在模块外面使用一些功能，那你就需要导入他们才能使用。最简单的就像下面这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, draw, reportArea, reportPerimeter &#125; <span class="keyword">from</span> <span class="string">&#x27;/js-examples/modules/basic-modules/modules/square.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>import</code> 语句，然后你被花括号包围的用逗号分隔的你想导入的功能列表，然后是关键字from，然后是模块文件的路径。模块文件的路径是相对于站点根目录的相对路径，对于我们的<code>basic-modules</code> 应该是<code> /js-examples/modules/basic-modules</code>。当然，我们写的路径有一点不同—我们使用点语法意味 “当前路径”，跟随着包含我们想要找的文件的路径。这比每次都要写下整个相对路径要好得多，因为它更短，使得URL 可移植。</p>
<p>值得注意的是，模块导出的值并不是复制了一份，而是<strong>导出了引用</strong>而已，虽然外部引用无法修改内部模块的成员变量，但模块内部导出成员发生变化后，导出的成员也会随之改变。</p>
<p>以下是一些注意事项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不能省略扩展名</span></span><br><span class="line"><span class="comment">// import &#123; name &#125; from &#x27;./module&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能自动识别目录下的index.js</span></span><br><span class="line"><span class="comment">// import &#123; name &#125; from &#x27;./modules&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用相对路径时不能省略./，否则会被识别为第三方模块</span></span><br><span class="line"><span class="comment">// import &#123; name &#125; from &#x27;modules.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块但不提取数据</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./modules.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出成员比较多时，可以将模块成员全部导出</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mod <span class="keyword">from</span> <span class="string">&#x27;./modules.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入模块：不能在导入语句中编写变量和嵌套在语句中</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./modeles.js&#x27;</span>).then(<span class="function"><span class="params">mod</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(mod.name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入一般成员和默认成员</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age, <span class="keyword">default</span> <span class="keyword">as</span> del &#125; <span class="keyword">from</span> <span class="string">&#x27;.modules.js&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="浏览器环境使用"><a href="#浏览器环境使用" class="headerlink" title="浏览器环境使用"></a>浏览器环境使用</h3><p>在已经支持了<code>es modules</code>规范的浏览器，我们可以直接使用<code>modules</code>类型的<code>&lt;script&gt;</code>进行模块文件导入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&#x27;X-UA-Compatible&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;IE=edge&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;viewport&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;width=device-width, initial-scale=1&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./modules.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在支持的浏览器上打开这个html文件是可以正常执行模块中的代码的，但不支持<code>es modules</code>的浏览器会忽略这种模块文件。</p>
<p>为了在不支持的浏览器中也能使用模块语法，我们可以<strong>借助第三方编译工具</strong>，比如<code>polyfill</code>，模块代码会被转换为低版本的js代码，并返回给浏览器执行。</p>
<p>比如我们使用<a href="https://github.com/ModuleLoader/browser-es-module-loader">browser-es-module-loader</a>这个模块来兼容低版本浏览器，安装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install browser-es-<span class="built_in">module</span>-loader</span><br></pre></td></tr></table></figure>

<p>在浏览器端，我们可以通过<code>unpkg.com</code>拼接模块名就可以获取到最新的js文件：比如这个模块就拼接为<a href="https://unpkg.com/browser-es-module-loader">https://unpkg.com/browser-es-module-loader</a>。我们引入html文件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&#x27;utf-8&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&#x27;X-UA-Compatible&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;IE=edge&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;viewport&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;width=device-width, initial-scale=1&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/promise-polyfill@8.2.0/dist/polyfill.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/browse/browser-es-module-loader@0.4.1/dist/babel-browser-build.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/browse/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules.js&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(name) </span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果存在资源请求限制，最好是把js文件下载到本地再引用。</p>
</blockquote>
<blockquote>
<p>注意，如果你的浏览器还不支持<code>Promise</code>还需要再安装一个编译Promise的模块，因为上面编译模块代码的第三方模块内部使用的是Promise语法进行回调。这里我们使用了<code>promise-polyfii</code>模块。</p>
</blockquote>
<p>另外一个问题，我们发现在支持<code>es modules</code>规范的浏览器，调用了两次模块代码，这是因为<code>&lt;script type=&quot;module&quot;&gt;</code>执行了一次，而<code>es-module-loader</code>又执行了一次，我们知道，这个模块是为了在不支持模块规范的浏览器中使用的，支持的就不需要使用了，所以我们使用一个<code>nomodule</code>的属性来标识：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/promise-polyfill@8.2.0/dist/polyfill.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/browse/browser-es-module-loader@0.4.1/dist/babel-browser-build.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/browse/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但这样的写法在生成环境是极不推荐的，生产环境的代码应该是编译后的代码，而且我们可以借助babel这样的工具自动完成，不需要那么麻烦。</p>
<h3 id="在Node环境中使用es-modules"><a href="#在Node环境中使用es-modules" class="headerlink" title="在Node环境中使用es modules"></a>在Node环境中使用<code>es modules</code></h3><blockquote>
<p>保证node版本大于8.5。</p>
</blockquote>
<p>在node中执行es modules的语法，需要做两个准备：</p>
<ul>
<li>将<code>.js</code>扩展名为<code>.mjs</code></li>
<li>使用node启动模块时带上<code>--experimental-modules</code>命令，目前来说，这仍是实验中的特性，所以不要在生成环境中使用。</li>
</ul>
<p>更改文件扩展名之后，我们就可以在node中使用es modules语法了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line">fs.writeFileSync(<span class="string">&#x27;./foo.txt&#x27;</span>, <span class="string">&#x27;es module writing&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node --experimental-modules index.mjs</span><br></pre></td></tr></table></figure>

<p>值得注意的是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用&#123;&#125;导出内置模块的成员</span></span><br><span class="line"><span class="keyword">import</span> &#123; writeFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="comment">// 但第三方模块不行，因为第三方模块都是默认导出，这个&#123;&#125;并不是解构的语法，</span></span><br><span class="line"><span class="comment">// 而内置模块能导出仅仅是做了兼容，将模块内部每个成员都进行了导出</span></span><br><span class="line"><span class="comment">// import &#123; camelCase &#125; from lodash</span></span><br><span class="line">writeFileSync(<span class="string">&#x27;./foo.txt&#x27;</span>, <span class="string">&#x27;es module writing2&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>此外，Node的内置成员也不能再访问：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模块加载函数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">require</span>)</span><br><span class="line"><span class="comment">// 模块对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>)</span><br><span class="line"><span class="comment">// 导出对象别名</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span>)</span><br><span class="line"><span class="comment">// 当前文件绝对路径</span></span><br><span class="line"><span class="built_in">console</span>.log(__filename)</span><br><span class="line"><span class="comment">// 当前文件夹所在目录</span></span><br><span class="line"><span class="built_in">console</span>.log(__dirname)</span><br></pre></td></tr></table></figure>

<p>但这些信息都可以从<code>import</code>函数的成员中转换得到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; dirname &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="keyword">import</span>.meta.url;</span><br><span class="line"><span class="keyword">const</span> __filename = fileURLToPath(url)</span><br><span class="line"><span class="built_in">console</span>.log(__filename)</span><br><span class="line"><span class="keyword">const</span> __dirname = dirname(__filename)</span><br><span class="line"><span class="built_in">console</span>.log(__dirname)</span><br></pre></td></tr></table></figure>

<p>最新版本的支持：</p>
<p>切换node版本到12.10以上，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvm use 12.10.0</span><br></pre></td></tr></table></figure>

<p>每次都加上<code>--experimental-modules</code>比较麻烦，我们在package.js中增加一个<code>type</code>字段：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    type: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，node默认执行环境就是<code>es modules</code>语法，而且文件扩展名不再需要使用<code>.mjs</code>，但是，如果你需要使用<code>CommonJS</code>语法，需要将扩展名修改为<code>.cjs</code>。</p>
<h2 id="使用babel兼容js版本问题"><a href="#使用babel兼容js版本问题" class="headerlink" title="使用babel兼容js版本问题"></a>使用babel兼容js版本问题</h2><p>为了兼容浏览器使用<code>es modules</code>规范，我们一般使用<code>babel</code>进行js版本编译，这样，我们就可以放心使用最新特性的js代码，也就包括了这些模块化开发机制。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @babel/node @balel/core @babel/preset-env --dev</span><br></pre></td></tr></table></figure>

<p>使用<code>babel-node</code>命令运行js即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn babel-node ./index.js --presets=@babel/preset-env</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为了能正常将模板代码编译为正常的js版本，需要使用<code>--presets=@babel/preset-env</code>指令，这是因为<code>babel</code>是插件化开发的，如果我们未设置插件，某些功能，比如模块代码编译，就无法正常工作。而<code>@babel/preset-env</code>相当于一个插件集模块，其中就包含了模块解析的插件。</p>
</blockquote>
<p>为了更方便的调用，我们可以使用<code>babel</code>的配置文件<code>.babelrc</code>来设置<code>presets</code>项：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这里引用<code>@babel/preset-env</code>插件集只是为了编译模块代码，我们还可以手动指定插件，比如编译模块代码的插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @babel/plugin-transform-modules-commonjs --dev</span><br></pre></td></tr></table></figure>

<p>然后配置文件使用<code>plugins</code>项导入：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;@babel/plugin-transform-modules-commonjs&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://javascript.ruanyifeng.com/nodejs/module.html">commonJS规范</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">Modules - MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
</search>
